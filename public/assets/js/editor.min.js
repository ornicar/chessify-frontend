var LichessEditor = function () { "use strict"; const e = { createElement: function (e, t) { return document.createElement(e, t) }, createElementNS: function (e, t, n) { return document.createElementNS(e, t, n) }, createTextNode: function (e) { return document.createTextNode(e) }, createComment: function (e) { return document.createComment(e) }, insertBefore: function (e, t, n) { e.insertBefore(t, n) }, removeChild: function (e, t) { e.removeChild(t) }, appendChild: function (e, t) { e.appendChild(t) }, parentNode: function (e) { return e.parentNode }, nextSibling: function (e) { return e.nextSibling }, tagName: function (e) { return e.tagName }, setTextContent: function (e, t) { e.textContent = t }, getTextContent: function (e) { return e.textContent }, isElement: function (e) { return 1 === e.nodeType }, isText: function (e) { return 3 === e.nodeType }, isComment: function (e) { return 8 === e.nodeType } }; function t(e, t, n, r, o) { return { sel: e, data: t, children: n, text: r, elm: o, key: void 0 === t ? void 0 : t.key } } const n = Array.isArray; function r(e) { return "string" == typeof e || "number" == typeof e || e instanceof String || e instanceof Number } function o(e) { return void 0 === e } function s(e) { return void 0 !== e } const i = t("", {}, [], void 0, void 0); function a(e, t) { var n, r; const o = e.key === t.key, s = (null === (n = e.data) || void 0 === n ? void 0 : n.is) === (null === (r = t.data) || void 0 === r ? void 0 : r.is); return e.sel === t.sel && o && s } function c(e, t, n) { var r; const o = {}; for (let s = t; s <= n; ++s) { const t = null === (r = e[s]) || void 0 === r ? void 0 : r.key; void 0 !== t && (o[t] = s) } return o } const u = ["create", "update", "remove", "destroy", "pre", "post"]; function h(e, t, n) { if (e.ns = "http://www.w3.org/2000/svg", "foreignObject" !== n && void 0 !== t) for (let r = 0; r < t.length; ++r) { const e = t[r].data; void 0 !== e && h(e, t[r].children, t[r].sel) } } function l(e, o, s) { let i, a, c, u = {}; if (void 0 !== s ? (null !== o && (u = o), n(s) ? i = s : r(s) ? a = s.toString() : s && s.sel && (i = [s])) : null != o && (n(o) ? i = o : r(o) ? a = o.toString() : o && o.sel ? i = [o] : u = o), void 0 !== i) for (c = 0; c < i.length; ++c)r(i[c]) && (i[c] = t(void 0, void 0, void 0, i[c], void 0)); return "s" !== e[0] || "v" !== e[1] || "g" !== e[2] || 3 !== e.length && "." !== e[3] && "#" !== e[3] || h(u, i, e), t(e, u, i, a, void 0) } function d(e, t) { let n; const r = t.elm; let o = e.data.attrs, s = t.data.attrs; if ((o || s) && o !== s) { for (n in o = o || {}, s = s || {}, s) { const e = s[n]; o[n] !== e && (!0 === e ? r.setAttribute(n, "") : !1 === e ? r.removeAttribute(n) : 120 !== n.charCodeAt(0) ? r.setAttribute(n, e) : 58 === n.charCodeAt(3) ? r.setAttributeNS("http://www.w3.org/XML/1998/namespace", n, e) : 58 === n.charCodeAt(5) ? r.setAttributeNS("http://www.w3.org/1999/xlink", n, e) : r.setAttribute(n, e)) } for (n in o) n in s || r.removeAttribute(n) } } const p = { create: d, update: d }; function f(e, t) { let n, r; const o = t.elm; let s = e.data.class, i = t.data.class; if ((s || i) && s !== i) { for (r in s = s || {}, i = i || {}, s) s[r] && !Object.prototype.hasOwnProperty.call(i, r) && o.classList.remove(r); for (r in i) n = i[r], n !== s[r] && o.classList[n ? "add" : "remove"](r) } } const m = { create: f, update: f }; function g(e, t, n) { if ("function" == typeof e) e.call(t, n, t); else if ("object" == typeof e) for (let r = 0; r < e.length; r++)g(e[r], t, n) } function b(e, t) { const n = e.type, r = t.data.on; r && r[n] && g(r[n], t, e) } function v(e, t) { const n = e.data.on, r = e.listener, o = e.elm, s = t && t.data.on, i = t && t.elm; let a; if (n !== s) { if (n && r) if (s) for (a in n) s[a] || o.removeEventListener(a, r, !1); else for (a in n) o.removeEventListener(a, r, !1); if (s) { const r = t.listener = e.listener || function e(t) { b(t, e.vnode) }; if (r.vnode = t, n) for (a in s) n[a] || i.addEventListener(a, r, !1); else for (a in s) i.addEventListener(a, r, !1) } } } const k = { create: v, update: v, destroy: v }; function w(e, t) { let n, r, o; const s = t.elm; let i = e.data.props, a = t.data.props; if ((i || a) && i !== a) for (n in i = i || {}, a = a || {}, a) r = a[n], o = i[n], o === r || "value" === n && s[n] === r || (s[n] = r) } const y = { create: w, update: w }, C = ["K", "Q", "k", "q"], S = ["a", "b", "c", "d", "e", "f", "g", "h"], E = ["1", "2", "3", "4", "5", "6", "7", "8"], q = ["white", "black"], x = ["pawn", "knight", "bishop", "rook", "queen", "king"], M = ["a", "h"]; function P(e) { return "role" in e } function A(e) { return e = (858993459 & (e -= e >>> 1 & 1431655765)) + (e >>> 2 & 858993459), Math.imul(e + (e >>> 4) & 252645135, 16843009) >> 24 } function R(e) { return (e = e >>> 8 & 16711935 | (16711935 & e) << 8) >>> 16 & 65535 | (65535 & e) << 16 } function O(e) { return R(e = (e = (e = e >>> 1 & 1431655765 | (1431655765 & e) << 1) >>> 2 & 858993459 | (858993459 & e) << 2) >>> 4 & 252645135 | (252645135 & e) << 4) } class T { constructor(e, t) { this.lo = e, this.hi = t, this.lo = 0 | e, this.hi = 0 | t } static fromSquare(e) { return e >= 32 ? new T(0, 1 << e - 32) : new T(1 << e, 0) } static fromRank(e) { return new T(255, 0).shl64(8 * e) } static fromFile(e) { return new T(16843009 << e, 16843009 << e) } static empty() { return new T(0, 0) } static full() { return new T(4294967295, 4294967295) } static corners() { return new T(129, 2164260864) } static center() { return new T(402653184, 24) } static backranks() { return new T(255, 4278190080) } static backrank(e) { return "white" === e ? new T(255, 0) : new T(0, 4278190080) } static lightSquares() { return new T(1437226410, 1437226410) } static darkSquares() { return new T(2857740885, 2857740885) } complement() { return new T(~this.lo, ~this.hi) } xor(e) { return new T(this.lo ^ e.lo, this.hi ^ e.hi) } union(e) { return new T(this.lo | e.lo, this.hi | e.hi) } intersect(e) { return new T(this.lo & e.lo, this.hi & e.hi) } diff(e) { return new T(this.lo & ~e.lo, this.hi & ~e.hi) } intersects(e) { return this.intersect(e).nonEmpty() } isDisjoint(e) { return this.intersect(e).isEmpty() } supersetOf(e) { return e.diff(this).isEmpty() } subsetOf(e) { return this.diff(e).isEmpty() } shr64(e) { return e >= 64 ? T.empty() : e >= 32 ? new T(this.hi >>> e - 32, 0) : e > 0 ? new T(this.lo >>> e ^ this.hi << 32 - e, this.hi >>> e) : this } shl64(e) { return e >= 64 ? T.empty() : e >= 32 ? new T(0, this.lo << e - 32) : e > 0 ? new T(this.lo << e, this.hi << e ^ this.lo >>> 32 - e) : this } bswap64() { return new T(R(this.hi), R(this.lo)) } rbit64() { return new T(O(this.hi), O(this.lo)) } minus64(e) { const t = this.lo - e.lo, n = (t & e.lo & 1) + (e.lo >>> 1) + (t >>> 1) >>> 31; return new T(t, this.hi - (e.hi + n)) } equals(e) { return this.lo === e.lo && this.hi === e.hi } size() { return A(this.lo) + A(this.hi) } isEmpty() { return 0 === this.lo && 0 === this.hi } nonEmpty() { return 0 !== this.lo || 0 !== this.hi } has(e) { return 0 != (e >= 32 ? this.hi & 1 << e - 32 : this.lo & 1 << e) } set(e, t) { return t ? this.with(e) : this.without(e) } with(e) { return e >= 32 ? new T(this.lo, this.hi | 1 << e - 32) : new T(this.lo | 1 << e, this.hi) } without(e) { return e >= 32 ? new T(this.lo, this.hi & ~(1 << e - 32)) : new T(this.lo & ~(1 << e), this.hi) } toggle(e) { return e >= 32 ? new T(this.lo, this.hi ^ 1 << e - 32) : new T(this.lo ^ 1 << e, this.hi) } last() { return 0 !== this.hi ? 63 - Math.clz32(this.hi) : 0 !== this.lo ? 31 - Math.clz32(this.lo) : void 0 } first() { return 0 !== this.lo ? 31 - Math.clz32(this.lo & -this.lo) : 0 !== this.hi ? 63 - Math.clz32(this.hi & -this.hi) : void 0 } withoutFirst() { return 0 !== this.lo ? new T(this.lo & this.lo - 1, this.hi) : new T(0, this.hi & this.hi - 1) } moreThanOne() { return 0 !== this.hi && 0 !== this.lo || 0 != (this.lo & this.lo - 1) || 0 != (this.hi & this.hi - 1) } singleSquare() { return this.moreThanOne() ? void 0 : this.last() } isSingleSquare() { return this.nonEmpty() && !this.moreThanOne() } *[Symbol.iterator]() { let e = this.lo, t = this.hi; for (; 0 !== e;) { const t = 31 - Math.clz32(e & -e); e ^= 1 << t, yield t } for (; 0 !== t;) { const e = 31 - Math.clz32(t & -t); t ^= 1 << e, yield 32 + e } } *reversed() { let e = this.lo, t = this.hi; for (; 0 !== t;) { const e = 31 - Math.clz32(t); t ^= 1 << e, yield 32 + e } for (; 0 !== e;) { const t = 31 - Math.clz32(e); e ^= 1 << t, yield t } } } class K { constructor() { } static default() { const e = new K; return e.reset(), e } static racingKings() { const e = new K; return e.occupied = new T(65535, 0), e.promoted = T.empty(), e.white = new T(61680, 0), e.black = new T(3855, 0), e.pawn = T.empty(), e.knight = new T(6168, 0), e.bishop = new T(9252, 0), e.rook = new T(16962, 0), e.queen = new T(129, 0), e.king = new T(33024, 0), e } static horde() { const e = new K; return e.occupied = new T(4294967295, 4294901862), e.promoted = T.empty(), e.white = new T(4294967295, 102), e.black = new T(0, 4294901760), e.pawn = new T(4294967295, 16711782), e.knight = new T(0, 1107296256), e.bishop = new T(0, 603979776), e.rook = new T(0, 2164260864), e.queen = new T(0, 134217728), e.king = new T(0, 268435456), e } reset() { this.occupied = new T(65535, 4294901760), this.promoted = T.empty(), this.white = new T(65535, 0), this.black = new T(0, 4294901760), this.pawn = new T(65280, 16711680), this.knight = new T(66, 1107296256), this.bishop = new T(36, 603979776), this.rook = new T(129, 2164260864), this.queen = new T(8, 134217728), this.king = new T(16, 268435456) } static empty() { const e = new K; return e.clear(), e } clear() { this.occupied = T.empty(), this.promoted = T.empty(); for (const e of q) this[e] = T.empty(); for (const e of x) this[e] = T.empty() } clone() { const e = new K; e.occupied = this.occupied, e.promoted = this.promoted; for (const t of q) e[t] = this[t]; for (const t of x) e[t] = this[t]; return e } equalsIgnorePromoted(e) { return !!this.white.equals(e.white) && x.every((t => this[t].equals(e[t]))) } equals(e) { return this.equalsIgnorePromoted(e) && this.promoted.equals(e.promoted) } getColor(e) { return this.white.has(e) ? "white" : this.black.has(e) ? "black" : void 0 } getRole(e) { for (const t of x) if (this[t].has(e)) return t } get(e) { const t = this.getColor(e); if (!t) return; return { color: t, role: this.getRole(e), promoted: this.promoted.has(e) } } take(e) { const t = this.get(e); return t && (this.occupied = this.occupied.without(e), this[t.color] = this[t.color].without(e), this[t.role] = this[t.role].without(e), t.promoted && (this.promoted = this.promoted.without(e))), t } set(e, t) { const n = this.take(e); return this.occupied = this.occupied.with(e), this[t.color] = this[t.color].with(e), this[t.role] = this[t.role].with(e), t.promoted && (this.promoted = this.promoted.with(e)), n } has(e) { return this.occupied.has(e) } *[Symbol.iterator]() { for (const e of this.occupied) yield [e, this.get(e)] } pieces(e, t) { return this[e].intersect(this[t]) } rooksAndQueens() { return this.rook.union(this.queen) } bishopsAndQueens() { return this.bishop.union(this.queen) } kingOf(e) { return this.king.intersect(this[e]).diff(this.promoted).singleSquare() } } class F { constructor() { } static empty() { const e = new F; for (const t of x) e[t] = 0; return e } static fromBoard(e, t) { const n = new F; for (const r of x) n[r] = e.pieces(t, r).size(); return n } clone() { const e = new F; for (const t of x) e[t] = this[t]; return e } equals(e) { return x.every((t => this[t] === e[t])) } add(e) { const t = new F; for (const n of x) t[n] = this[n] + e[n]; return t } nonEmpty() { return x.some((e => this[e] > 0)) } isEmpty() { return !this.nonEmpty() } hasPawns() { return this.pawn > 0 } hasNonPawns() { return this.knight > 0 || this.bishop > 0 || this.rook > 0 || this.queen > 0 || this.king > 0 } count() { return this.pawn + this.knight + this.bishop + this.rook + this.queen + this.king } } class N { constructor(e, t) { this.white = e, this.black = t } static empty() { return new N(F.empty(), F.empty()) } static fromBoard(e) { return new N(F.fromBoard(e, "white"), F.fromBoard(e, "black")) } clone() { return new N(this.white.clone(), this.black.clone()) } equals(e) { return this.white.equals(e.white) && this.black.equals(e.black) } add(e) { return new N(this.white.add(e.white), this.black.add(e.black)) } count() { return this.white.count() + this.black.count() } isEmpty() { return this.white.isEmpty() && this.black.isEmpty() } nonEmpty() { return !this.isEmpty() } hasPawns() { return this.white.hasPawns() || this.black.hasPawns() } hasNonPawns() { return this.white.hasNonPawns() || this.black.hasNonPawns() } } class I { constructor(e, t) { this.white = e, this.black = t } static default() { return new I(3, 3) } clone() { return new I(this.white, this.black) } equals(e) { return this.white === e.white && this.black === e.black } } function L(e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t } var B, D = function () { function e() { } var t = e.prototype; return t.unwrap = function (e, t) { var n = this._chain((function (t) { return B.ok(e ? e(t) : t) }), (function (e) { return t ? B.ok(t(e)) : B.err(e) })); if (n.isErr) throw n.error; return n.value }, t.map = function (e, t) { return this._chain((function (t) { return B.ok(e(t)) }), (function (e) { return B.err(t ? t(e) : e) })) }, t.chain = function (e, t) { return this._chain(e, t || function (e) { return B.err(e) }) }, e }(), z = function (e) { function t(t) { var n; return (n = e.call(this) || this).value = t, n.isOk = !0, n.isErr = !1, n } return L(t, e), t.prototype._chain = function (e, t) { return e(this.value) }, t }(D), _ = function (e) { function t(t) { var n; return (n = e.call(this) || this).error = t, n.isOk = !1, n.isErr = !0, n } return L(t, e), t.prototype._chain = function (e, t) { return t(this.error) }, t }(D); function V(e) { return void 0 !== e } function j(e) { return "white" === e ? "black" : "white" } function H(e) { return e >> 3 } function Q(e) { return 7 & e } function W(e) { switch (e) { case "pawn": return "p"; case "knight": return "n"; case "bishop": return "b"; case "rook": return "r"; case "queen": return "q"; case "king": return "k" } } function U(e, t) { return "white" === e ? "a" === t ? 2 : 6 : "a" === t ? 58 : 62 } function X(e, t) { let n = T.empty(); for (const r of t) { const t = e + r; 0 <= t && t < 64 && Math.abs(Q(e) - Q(t)) <= 2 && (n = n.with(t)) } return n } function Y(e) { const t = []; for (let n = 0; n < 64; n++)t[n] = e(n); return t } !function (e) { e.ok = function (e) { return new z(e) }, e.err = function (e) { return new _(e || new Error) }, e.all = function (t) { if (Array.isArray(t)) { for (var n = [], r = 0; r < t.length; r++) { var o = t[r]; if (o.isErr) return o; n.push(o.value) } return e.ok(n) } for (var s = {}, i = Object.keys(t), a = 0; a < i.length; a++) { var c = t[i[a]]; if (c.isErr) return c; s[i[a]] = c.value } return e.ok(s) } }(B || (B = {})); const G = Y((e => X(e, [-9, -8, -7, -1, 1, 7, 8, 9]))), Z = Y((e => X(e, [-17, -15, -10, -6, 6, 10, 15, 17]))), J = { white: Y((e => X(e, [7, 9]))), black: Y((e => X(e, [-7, -9]))) }; function ee(e) { return G[e] } function te(e) { return Z[e] } function ne(e, t) { return J[e][t] } const re = Y((e => T.fromFile(Q(e)).without(e))), oe = Y((e => T.fromRank(H(e)).without(e))), se = Y((e => { const t = new T(134480385, 2151686160), n = 8 * (H(e) - Q(e)); return (n >= 0 ? t.shl64(n) : t.shr64(-n)).without(e) })), ie = Y((e => { const t = new T(270549120, 16909320), n = 8 * (H(e) + Q(e) - 7); return (n >= 0 ? t.shl64(n) : t.shr64(-n)).without(e) })); function ae(e, t, n) { let r = n.intersect(t), o = r.bswap64(); return r = r.minus64(e), o = o.minus64(e.bswap64()), r.xor(o.bswap64()).intersect(t) } function ce(e, t) { const n = T.fromSquare(e); return ae(n, se[e], t).xor(ae(n, ie[e], t)) } function ue(e, t) { return function (e, t) { return ae(T.fromSquare(e), re[e], t) }(e, t).xor(function (e, t) { const n = oe[e]; let r = t.intersect(n), o = r.rbit64(); return r = r.minus64(T.fromSquare(e)), o = o.minus64(T.fromSquare(63 - e)), r.xor(o.rbit64()).intersect(n) }(e, t)) } function he(e, t) { return ce(e, t).xor(ue(e, t)) } function le(e, t) { const n = T.fromSquare(t); return oe[e].intersects(n) ? oe[e].with(e) : ie[e].intersects(n) ? ie[e].with(e) : se[e].intersects(n) ? se[e].with(e) : re[e].intersects(n) ? re[e].with(e) : T.empty() } function de(e, t) { return le(e, t).intersect(T.full().shl64(e).xor(T.full().shl64(t))).withoutFirst() } var pe; !function (e) { e.Empty = "ERR_EMPTY", e.OppositeCheck = "ERR_OPPOSITE_CHECK", e.ImpossibleCheck = "ERR_IMPOSSIBLE_CHECK", e.PawnsOnBackrank = "ERR_PAWNS_ON_BACKRANK", e.Kings = "ERR_KINGS", e.Variant = "ERR_VARIANT" }(pe || (pe = {})); class fe extends Error { } function me(e, t) { return "white" === e ? "a" === t ? 3 : 5 : "a" === t ? 59 : 61 } class ge { constructor() { } static default() { const e = new ge; return e.unmovedRooks = T.corners(), e.rook = { white: { a: 0, h: 7 }, black: { a: 56, h: 63 } }, e.path = { white: { a: new T(14, 0), h: new T(96, 0) }, black: { a: new T(0, 234881024), h: new T(0, 1610612736) } }, e } static empty() { const e = new ge; return e.unmovedRooks = T.empty(), e.rook = { white: { a: void 0, h: void 0 }, black: { a: void 0, h: void 0 } }, e.path = { white: { a: T.empty(), h: T.empty() }, black: { a: T.empty(), h: T.empty() } }, e } clone() { const e = new ge; return e.unmovedRooks = this.unmovedRooks, e.rook = { white: { a: this.rook.white.a, h: this.rook.white.h }, black: { a: this.rook.black.a, h: this.rook.black.h } }, e.path = { white: { a: this.path.white.a, h: this.path.white.h }, black: { a: this.path.black.a, h: this.path.black.h } }, e } add(e, t, n, r) { const o = U(e, t), s = me(e, t); this.unmovedRooks = this.unmovedRooks.with(r), this.rook[e][t] = r, this.path[e][t] = de(r, s).with(s).union(de(n, o).with(o)).without(n).without(r) } static fromSetup(e) { const t = ge.empty(), n = e.unmovedRooks.intersect(e.board.rook); for (const r of q) { const o = T.backrank(r), s = e.board.kingOf(r); if (!V(s) || !o.has(s)) continue; const i = n.intersect(e.board[r]).intersect(o), a = i.first(); V(a) && a < s && t.add(r, "a", s, a); const c = i.last(); V(c) && s < c && t.add(r, "h", s, c) } return t } discardRook(e) { if (this.unmovedRooks.has(e)) { this.unmovedRooks = this.unmovedRooks.without(e); for (const t of q) for (const n of M) this.rook[t][n] === e && (this.rook[t][n] = void 0) } } discardSide(e) { this.unmovedRooks = this.unmovedRooks.diff(T.backrank(e)), this.rook[e].a = void 0, this.rook[e].h = void 0 } } class be extends class { constructor(e) { this.rules = e } kingAttackers(e, t, n) { return function (e, t, n, r) { return n[t].intersect(ue(e, r).intersect(n.rooksAndQueens()).union(ce(e, r).intersect(n.bishopsAndQueens())).union(te(e).intersect(n.knight)).union(ee(e).intersect(n.king)).union(ne(j(t), e).intersect(n.pawn))) }(e, t, this.board, n) } dropDests(e) { return T.empty() } playCaptureAt(e, t) { this.halfmoves = 0, "rook" === t.role && this.castles.discardRook(e), this.pockets && this.pockets[j(t.color)][t.role]++ } ctx() { const e = this.isVariantEnd(), t = this.board.kingOf(this.turn); if (!V(t)) return { king: t, blockers: T.empty(), checkers: T.empty(), variantEnd: e, mustCapture: !1 }; const n = ue(t, T.empty()).intersect(this.board.rooksAndQueens()).union(ce(t, T.empty()).intersect(this.board.bishopsAndQueens())).intersect(this.board[j(this.turn)]); let r = T.empty(); for (const o of n) { const e = de(t, o).intersect(this.board.occupied); e.moreThanOne() || (r = r.union(e)) } return { king: t, blockers: r, checkers: this.kingAttackers(t, j(this.turn), this.board.occupied), variantEnd: e, mustCapture: !1 } } clone() { var e, t; const n = new this.constructor; return n.board = this.board.clone(), n.pockets = null === (e = this.pockets) || void 0 === e ? void 0 : e.clone(), n.turn = this.turn, n.castles = this.castles.clone(), n.epSquare = this.epSquare, n.remainingChecks = null === (t = this.remainingChecks) || void 0 === t ? void 0 : t.clone(), n.halfmoves = this.halfmoves, n.fullmoves = this.fullmoves, n } equalsIgnoreMoves(e) { var t, n; return this.rules === e.rules && (this.pockets ? this.board.equals(e.board) : this.board.equalsIgnorePromoted(e.board)) && (e.pockets && (null === (t = this.pockets) || void 0 === t ? void 0 : t.equals(e.pockets)) || !this.pockets && !e.pockets) && this.turn === e.turn && this.castles.unmovedRooks.equals(e.castles.unmovedRooks) && this.legalEpSquare() === e.legalEpSquare() && (e.remainingChecks && (null === (n = this.remainingChecks) || void 0 === n ? void 0 : n.equals(e.remainingChecks)) || !this.remainingChecks && !e.remainingChecks) } toSetup() { var e, t; return { board: this.board.clone(), pockets: null === (e = this.pockets) || void 0 === e ? void 0 : e.clone(), turn: this.turn, unmovedRooks: this.castles.unmovedRooks, epSquare: this.legalEpSquare(), remainingChecks: null === (t = this.remainingChecks) || void 0 === t ? void 0 : t.clone(), halfmoves: Math.min(this.halfmoves, 150), fullmoves: Math.min(Math.max(this.fullmoves, 1), 9999) } } isInsufficientMaterial() { return q.every((e => this.hasInsufficientMaterial(e))) } hasDests(e) { e = e || this.ctx(); for (const t of this.board[this.turn]) if (this.dests(t, e).nonEmpty()) return !0; return this.dropDests(e).nonEmpty() } isLegal(e, t) { if (P(e)) return !(!this.pockets || this.pockets[this.turn][e.role] <= 0) && (("pawn" !== e.role || !T.backranks().has(e.to)) && this.dropDests(t).has(e.to)); { if ("pawn" === e.promotion) return !1; if ("king" === e.promotion && "antichess" !== this.rules) return !1; if (!!e.promotion !== (this.board.pawn.has(e.from) && T.backranks().has(e.to))) return !1; const n = this.dests(e.from, t); return n.has(e.to) || n.has(this.normalizeMove(e).to) } } isCheck() { const e = this.board.kingOf(this.turn); return V(e) && this.kingAttackers(e, j(this.turn), this.board.occupied).nonEmpty() } isEnd(e) { return !!(e ? e.variantEnd : this.isVariantEnd()) || (this.isInsufficientMaterial() || !this.hasDests(e)) } isCheckmate(e) { return !(e = e || this.ctx()).variantEnd && e.checkers.nonEmpty() && !this.hasDests(e) } isStalemate(e) { return !(e = e || this.ctx()).variantEnd && e.checkers.isEmpty() && !this.hasDests(e) } outcome(e) { const t = this.variantOutcome(e); return t || (e = e || this.ctx(), this.isCheckmate(e) ? { winner: j(this.turn) } : this.isInsufficientMaterial() || this.isStalemate(e) ? { winner: void 0 } : void 0) } allDests(e) { e = e || this.ctx(); const t = new Map; if (e.variantEnd) return t; for (const n of this.board[this.turn]) t.set(n, this.dests(n, e)); return t } castlingSide(e) { if (P(e)) return; const t = e.to - e.from; return (2 === Math.abs(t) || this.board[this.turn].has(e.to)) && this.board.king.has(e.from) ? t > 0 ? "h" : "a" : void 0 } normalizeMove(e) { const t = this.castlingSide(e); if (!t) return e; const n = this.castles.rook[this.turn][t]; return { from: e.from, to: V(n) ? n : e.to } } play(e) { const t = this.turn, n = this.epSquare, r = this.castlingSide(e); if (this.epSquare = void 0, this.halfmoves += 1, "black" === t && (this.fullmoves += 1), this.turn = j(t), P(e)) this.board.set(e.to, { role: e.role, color: t }), this.pockets && this.pockets[t][e.role]--, "pawn" === e.role && (this.halfmoves = 0); else { const o = this.board.take(e.from); if (!o) return; let s; if ("pawn" === o.role) { this.halfmoves = 0, e.to === n && (s = this.board.take(e.to + ("white" === t ? -8 : 8))); const r = e.from - e.to; 16 === Math.abs(r) && 8 <= e.from && e.from <= 55 && (this.epSquare = e.from + e.to >> 1), e.promotion && (o.role = e.promotion, o.promoted = !0) } else if ("rook" === o.role) this.castles.discardRook(e.from); else if ("king" === o.role) { if (r) { const e = this.castles.rook[t][r]; if (V(e)) { const n = this.board.take(e); this.board.set(U(t, r), o), n && this.board.set(me(t, r), n) } } this.castles.discardSide(t) } if (!r) { const t = this.board.set(e.to, o) || s; t && this.playCaptureAt(e.to, t) } } this.remainingChecks && this.isCheck() && (this.remainingChecks[t] = Math.max(this.remainingChecks[t] - 1, 0)) } legalEpSquare(e) { if (!V(this.epSquare)) return; e = e || this.ctx(); const t = this.board.pieces(this.turn, "pawn").intersect(ne(j(this.turn), this.epSquare)); for (const n of t) if (this.dests(n, e).has(this.epSquare)) return this.epSquare } }{ constructor(e) { super(e || "chess") } static default() { const e = new this; return e.board = K.default(), e.pockets = void 0, e.turn = "white", e.castles = ge.default(), e.epSquare = void 0, e.remainingChecks = void 0, e.halfmoves = 0, e.fullmoves = 1, e } static fromSetup(e) { const t = new this; return t.board = e.board.clone(), t.pockets = void 0, t.turn = e.turn, t.castles = ge.fromSetup(e), t.epSquare = t.validEpSquare(e.epSquare), t.remainingChecks = void 0, t.halfmoves = e.halfmoves, t.fullmoves = e.fullmoves, t.validate().map((e => t)) } clone() { return super.clone() } validate() { if (this.board.occupied.isEmpty()) return B.err(new fe(pe.Empty)); if (2 !== this.board.king.size()) return B.err(new fe(pe.Kings)); if (!V(this.board.kingOf(this.turn))) return B.err(new fe(pe.Kings)); const e = this.board.kingOf(j(this.turn)); return V(e) ? this.kingAttackers(e, this.turn, this.board.occupied).nonEmpty() ? B.err(new fe(pe.OppositeCheck)) : T.backranks().intersects(this.board.pawn) ? B.err(new fe(pe.PawnsOnBackrank)) : this.validateCheckers() : B.err(new fe(pe.Kings)) } validateCheckers() { const e = this.board.kingOf(this.turn); if (V(e)) { const t = this.kingAttackers(e, j(this.turn), this.board.occupied); if (t.size() > 2 || 2 === t.size() && le(t.first(), t.last()).has(e)) return B.err(new fe(pe.ImpossibleCheck)); if (V(this.epSquare)) for (const n of t) if (le(n, this.epSquare).has(e)) return B.err(new fe(pe.ImpossibleCheck)) } return B.ok(void 0) } validEpSquare(e) { if (!V(e)) return; const t = "white" === this.turn ? 5 : 2, n = "white" === this.turn ? 8 : -8; if (H(e) !== t) return; if (this.board.occupied.has(e + n)) return; const r = e - n; return this.board.pawn.has(r) && this.board[j(this.turn)].has(r) ? e : void 0 } castlingDest(e, t) { if (!V(t.king) || t.checkers.nonEmpty()) return T.empty(); const n = this.castles.rook[this.turn][e]; if (!V(n)) return T.empty(); if (this.castles.path[this.turn][e].intersects(this.board.occupied)) return T.empty(); const r = U(this.turn, e), o = de(t.king, r), s = this.board.occupied.without(t.king); for (const c of o) if (this.kingAttackers(c, j(this.turn), s).nonEmpty()) return T.empty(); const i = me(this.turn, e), a = this.board.occupied.toggle(t.king).toggle(n).toggle(i); return this.kingAttackers(r, j(this.turn), a).nonEmpty() ? T.empty() : T.fromSquare(n) } canCaptureEp(e, t) { if (!V(this.epSquare)) return !1; if (!ne(this.turn, e).has(this.epSquare)) return !1; if (!V(t.king)) return !0; const n = this.epSquare + ("white" === this.turn ? -8 : 8), r = this.board.occupied.toggle(e).toggle(this.epSquare).toggle(n); return !this.kingAttackers(t.king, j(this.turn), r).intersects(r) } pseudoDests(e, t) { if (t.variantEnd) return T.empty(); const n = this.board.get(e); if (!n || n.color !== this.turn) return T.empty(); let r = function (e, t, n) { switch (e.role) { case "pawn": return ne(e.color, t); case "knight": return te(t); case "bishop": return ce(t, n); case "rook": return ue(t, n); case "queen": return he(t, n); case "king": return ee(t) } }(n, e, this.board.occupied); if ("pawn" === n.role) { let t = this.board[j(this.turn)]; V(this.epSquare) && (t = t.with(this.epSquare)), r = r.intersect(t); const n = "white" === this.turn ? 8 : -8, o = e + n; if (0 <= o && o < 64 && !this.board.occupied.has(o)) { r = r.with(o); const t = o + n; ("white" === this.turn ? e < 16 : e >= 48) && !this.board.occupied.has(t) && (r = r.with(t)) } return r } return r = r.diff(this.board[this.turn]), e === t.king ? r.union(this.castlingDest("a", t)).union(this.castlingDest("h", t)) : r } dests(e, t) { if ((t = t || this.ctx()).variantEnd) return T.empty(); const n = this.board.get(e); if (!n || n.color !== this.turn) return T.empty(); let r, o; if ("pawn" === n.role) { r = ne(this.turn, e).intersect(this.board[j(this.turn)]); const n = "white" === this.turn ? 8 : -8, s = e + n; if (0 <= s && s < 64 && !this.board.occupied.has(s)) { r = r.with(s); const t = s + n; ("white" === this.turn ? e < 16 : e >= 48) && !this.board.occupied.has(t) && (r = r.with(t)) } if (V(this.epSquare) && this.canCaptureEp(e, t)) { const e = this.epSquare - n; (t.checkers.isEmpty() || t.checkers.singleSquare() === e) && (o = T.fromSquare(this.epSquare)) } } else r = "bishop" === n.role ? ce(e, this.board.occupied) : "knight" === n.role ? te(e) : "rook" === n.role ? ue(e, this.board.occupied) : "queen" === n.role ? he(e, this.board.occupied) : ee(e); if (r = r.diff(this.board[this.turn]), V(t.king)) { if ("king" === n.role) { const n = this.board.occupied.without(e); for (const e of r) this.kingAttackers(e, j(this.turn), n).nonEmpty() && (r = r.without(e)); return r.union(this.castlingDest("a", t)).union(this.castlingDest("h", t)) } if (t.checkers.nonEmpty()) { const e = t.checkers.singleSquare(); if (!V(e)) return T.empty(); r = r.intersect(de(e, t.king).with(e)) } t.blockers.has(e) && (r = r.intersect(le(e, t.king))) } return o && (r = r.union(o)), r } isVariantEnd() { return !1 } variantOutcome(e) { } hasInsufficientMaterial(e) { if (this.board[e].intersect(this.board.pawn.union(this.board.rooksAndQueens())).nonEmpty()) return !1; if (this.board[e].intersects(this.board.knight)) return this.board[e].size() <= 2 && this.board[j(e)].diff(this.board.king).diff(this.board.queen).isEmpty(); if (this.board[e].intersects(this.board.bishop)) { return (!this.board.bishop.intersects(T.darkSquares()) || !this.board.bishop.intersects(T.lightSquares())) && this.board.pawn.isEmpty() && this.board.knight.isEmpty() } return !0 } } class ve extends be { constructor() { super("crazyhouse") } static default() { const e = super.default(); return e.pockets = N.empty(), e } static fromSetup(e) { return super.fromSetup(e).map((t => (t.pockets = e.pockets ? e.pockets.clone() : N.empty(), t))) } validate() { return super.validate().chain((e => this.pockets && (this.pockets.white.king > 0 || this.pockets.black.king > 0) ? B.err(new fe(pe.Kings)) : (this.pockets ? this.pockets.count() : 0) + this.board.occupied.size() > 64 ? B.err(new fe(pe.Variant)) : B.ok(void 0))) } clone() { return super.clone() } hasInsufficientMaterial(e) { return this.pockets ? this.board.occupied.size() + this.pockets.count() <= 3 && this.board.pawn.isEmpty() && this.board.promoted.isEmpty() && this.board.rooksAndQueens().isEmpty() && this.pockets.white.pawn <= 0 && this.pockets.black.pawn <= 0 && this.pockets.white.rook <= 0 && this.pockets.black.rook <= 0 && this.pockets.white.queen <= 0 && this.pockets.black.queen <= 0 : super.hasInsufficientMaterial(e) } dropDests(e) { var t, n; const r = this.board.occupied.complement().intersect((null === (t = this.pockets) || void 0 === t ? void 0 : t[this.turn].hasNonPawns()) ? T.full() : (null === (n = this.pockets) || void 0 === n ? void 0 : n[this.turn].hasPawns()) ? T.backranks().complement() : T.empty()); if (V((e = e || this.ctx()).king) && e.checkers.nonEmpty()) { const t = e.checkers.singleSquare(); return V(t) ? r.intersect(de(t, e.king)) : T.empty() } return r } } class ke extends be { constructor() { super("atomic") } static default() { return super.default() } static fromSetup(e) { return super.fromSetup(e) } clone() { return super.clone() } validate() { if (this.board.occupied.isEmpty()) return B.err(new fe(pe.Empty)); if (this.board.king.size() > 2) return B.err(new fe(pe.Kings)); const e = this.board.kingOf(j(this.turn)); return V(e) ? this.kingAttackers(e, this.turn, this.board.occupied).nonEmpty() ? B.err(new fe(pe.OppositeCheck)) : T.backranks().intersects(this.board.pawn) ? B.err(new fe(pe.PawnsOnBackrank)) : B.ok(void 0) : B.err(new fe(pe.Kings)) } kingAttackers(e, t, n) { const r = this.board.pieces(t, "king"); return r.isEmpty() || ee(e).intersects(r) ? T.empty() : super.kingAttackers(e, t, n) } playCaptureAt(e, t) { super.playCaptureAt(e, t), this.board.take(e); for (const n of ee(e).intersect(this.board.occupied).diff(this.board.pawn)) { const e = this.board.take(n); e && "rook" === e.role && this.castles.discardRook(n), e && "king" === e.role && this.castles.discardSide(e.color) } } hasInsufficientMaterial(e) { if (this.board.pieces(j(e), "king").isEmpty()) return !1; if (this.board[e].diff(this.board.king).isEmpty()) return !0; if (this.board[j(e)].diff(this.board.king).nonEmpty()) { if (this.board.occupied.equals(this.board.bishop.union(this.board.king))) { if (!this.board.bishop.intersect(this.board.white).intersects(T.darkSquares())) return !this.board.bishop.intersect(this.board.black).intersects(T.lightSquares()); if (!this.board.bishop.intersect(this.board.white).intersects(T.lightSquares())) return !this.board.bishop.intersect(this.board.black).intersects(T.darkSquares()) } return !1 } return !this.board.queen.nonEmpty() && !this.board.pawn.nonEmpty() && (!!this.board.knight.union(this.board.bishop).union(this.board.rook).isSingleSquare() || !!this.board.occupied.equals(this.board.knight.union(this.board.king)) && this.board.knight.size() <= 2) } dests(e, t) { t = t || this.ctx(); let n = T.empty(); for (const r of this.pseudoDests(e, t)) { const t = this.clone(); t.play({ from: e, to: r }); const o = t.board.kingOf(this.turn); !V(o) || V(t.board.kingOf(t.turn)) && !t.kingAttackers(o, t.turn, t.board.occupied).isEmpty() || (n = n.with(r)) } return n } isVariantEnd() { return !!this.variantOutcome() } variantOutcome(e) { for (const t of q) if (this.board.pieces(t, "king").isEmpty()) return { winner: j(t) } } } class we extends be { constructor() { super("antichess") } static default() { const e = super.default(); return e.castles = ge.empty(), e } static fromSetup(e) { return super.fromSetup(e).map((e => (e.castles = ge.empty(), e))) } clone() { return super.clone() } validate() { return this.board.occupied.isEmpty() ? B.err(new fe(pe.Empty)) : T.backranks().intersects(this.board.pawn) ? B.err(new fe(pe.PawnsOnBackrank)) : B.ok(void 0) } kingAttackers(e, t, n) { return T.empty() } ctx() { const e = super.ctx(), t = this.board[j(this.turn)]; for (const n of this.board[this.turn]) if (this.pseudoDests(n, e).intersects(t)) { e.mustCapture = !0; break } return e } dests(e, t) { t = t || this.ctx(); const n = this.pseudoDests(e, t); return t.mustCapture ? n.intersect(this.board[j(this.turn)]) : n } hasInsufficientMaterial(e) { if (this.board.occupied.equals(this.board.bishop)) { const t = this.board[e].intersects(T.lightSquares()), n = this.board[e].intersects(T.darkSquares()), r = this.board[j(e)].isDisjoint(T.lightSquares()), o = this.board[j(e)].isDisjoint(T.darkSquares()); return t && r || n && o } return !1 } isVariantEnd() { return this.board[this.turn].isEmpty() } variantOutcome(e) { if ((e = e || this.ctx()).variantEnd || this.isStalemate(e)) return { winner: this.turn } } } class ye extends be { constructor() { super("kingofthehill") } static default() { return super.default() } static fromSetup(e) { return super.fromSetup(e) } clone() { return super.clone() } hasInsufficientMaterial(e) { return !1 } isVariantEnd() { return this.board.king.intersects(T.center()) } variantOutcome(e) { for (const t of q) if (this.board.pieces(t, "king").intersects(T.center())) return { winner: t } } } class Ce extends be { constructor() { super("3check") } static default() { const e = super.default(); return e.remainingChecks = I.default(), e } static fromSetup(e) { return super.fromSetup(e).map((t => (t.remainingChecks = e.remainingChecks ? e.remainingChecks.clone() : I.default(), t))) } clone() { return super.clone() } hasInsufficientMaterial(e) { return this.board.pieces(e, "king").equals(this.board[e]) } isVariantEnd() { return !!this.remainingChecks && (this.remainingChecks.white <= 0 || this.remainingChecks.black <= 0) } variantOutcome(e) { if (this.remainingChecks) for (const t of q) if (this.remainingChecks[t] <= 0) return { winner: t } } } class Se extends be { constructor() { super("racingkings") } static default() { const e = new this; return e.board = K.racingKings(), e.pockets = void 0, e.turn = "white", e.castles = ge.empty(), e.epSquare = void 0, e.remainingChecks = void 0, e.halfmoves = 0, e.fullmoves = 1, e } static fromSetup(e) { return super.fromSetup(e).map((e => (e.castles = ge.empty(), e))) } validate() { return this.isCheck() ? B.err(new fe(pe.ImpossibleCheck)) : this.board.pawn.nonEmpty() ? B.err(new fe(pe.Variant)) : super.validate() } clone() { return super.clone() } dests(e, t) { if (e === (t = t || this.ctx()).king) return super.dests(e, t); let n = T.empty(); for (const r of super.dests(e, t)) { const t = { from: e, to: r }, o = this.clone(); o.play(t), o.isCheck() || (n = n.with(r)) } return n } hasInsufficientMaterial(e) { return !1 } isVariantEnd() { const e = T.fromRank(7), t = this.board.king.intersect(e); if (t.isEmpty()) return !1; if ("white" === this.turn || t.intersects(this.board.black)) return !0; const n = this.board.kingOf("black"); if (V(n)) { const t = this.board.occupied.without(n); for (const r of ee(n).intersect(e).diff(this.board.black)) if (this.kingAttackers(r, "white", t).isEmpty()) return !1 } return !0 } variantOutcome(e) { if (e ? !e.variantEnd : !this.isVariantEnd()) return; const t = T.fromRank(7), n = this.board.pieces("black", "king").intersects(t), r = this.board.pieces("white", "king").intersects(t); return n && !r ? { winner: "black" } : r && !n ? { winner: "white" } : { winner: void 0 } } } class Ee extends be { constructor() { super("horde") } static default() { const e = new this; return e.board = K.horde(), e.pockets = void 0, e.turn = "white", e.castles = ge.default(), e.castles.discardSide("white"), e.epSquare = void 0, e.remainingChecks = void 0, e.halfmoves = 0, e.fullmoves = 1, e } static fromSetup(e) { return super.fromSetup(e) } validate() { if (this.board.occupied.isEmpty()) return B.err(new fe(pe.Empty)); if (!this.board.king.isSingleSquare()) return B.err(new fe(pe.Kings)); if (!this.board.king.diff(this.board.promoted).isSingleSquare()) return B.err(new fe(pe.Kings)); const e = this.board.kingOf(j(this.turn)); if (V(e) && this.kingAttackers(e, this.turn, this.board.occupied).nonEmpty()) return B.err(new fe(pe.OppositeCheck)); for (const t of q) if (this.board.pieces(t, "pawn").intersects(T.backrank(j(t)))) return B.err(new fe(pe.PawnsOnBackrank)); return this.validateCheckers() } clone() { return super.clone() } hasInsufficientMaterial(e) { return !1 } isVariantEnd() { return this.board.white.isEmpty() || this.board.black.isEmpty() } variantOutcome(e) { return this.board.white.isEmpty() ? { winner: "black" } : this.board.black.isEmpty() ? { winner: "white" } : void 0 } } function qe(e, t) { switch (e) { case "chess": return be.fromSetup(t); case "antichess": return we.fromSetup(t); case "atomic": return ke.fromSetup(t); case "horde": return Ee.fromSetup(t); case "racingkings": return Se.fromSetup(t); case "kingofthehill": return ye.fromSetup(t); case "3check": return Ce.fromSetup(t); case "crazyhouse": return ve.fromSetup(t) } } const xe = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -", Me = xe + " 0 1", Pe = "8/8/8/8/8/8/8/8 w - - 0 1"; var Ae; !function (e) { e.Fen = "ERR_FEN", e.Board = "ERR_BOARD", e.Pockets = "ERR_POCKETS", e.Turn = "ERR_TURN", e.Castling = "ERR_CASTLING", e.EpSquare = "ERR_EP_SQUARE", e.RemainingChecks = "ERR_REMAINING_CHECKS", e.Halfmoves = "ERR_HALFMOVES", e.Fullmoves = "ERR_FULLMOVES" }(Ae || (Ae = {})); class Re extends Error { } function Oe(e) { return /^\d{1,4}$/.test(e) ? parseInt(e, 10) : void 0 } function Te(e) { const t = function (e) { switch (e) { case "P": case "p": return "pawn"; case "N": case "n": return "knight"; case "B": case "b": return "bishop"; case "R": case "r": return "rook"; case "Q": case "q": return "queen"; case "K": case "k": return "king"; default: return } }(e); return t && { role: t, color: e.toLowerCase() === e ? "black" : "white" } } function Ke(e) { const t = K.empty(); let n = 7, r = 0; for (let o = 0; o < e.length; o++) { const s = e[o]; if ("/" === s && 8 === r) r = 0, n--; else { const i = parseInt(s, 10); if (i > 0) r += i; else { if (r >= 8 || n < 0) return B.err(new Re(Ae.Board)); const i = r + 8 * n, a = Te(s); if (!a) return B.err(new Re(Ae.Board)); "~" === e[o + 1] && (a.promoted = !0, o++), t.set(i, a), r++ } } } return 0 !== n || 8 !== r ? B.err(new Re(Ae.Board)) : B.ok(t) } function Fe(e) { if (e.length > 64) return B.err(new Re(Ae.Pockets)); const t = N.empty(); for (const n of e) { const e = Te(n); if (!e) return B.err(new Re(Ae.Pockets)); t[e.color][e.role]++ } return B.ok(t) } function Ne(e, t) { let n = T.empty(); if ("-" === t) return B.ok(n); if (!/^[KQABCDEFGH]{0,2}[kqabcdefgh]{0,2}$/.test(t)) return B.err(new Re(Ae.Castling)); for (const r of t) { const t = r.toLowerCase(), o = r === t ? "black" : "white", s = T.backrank(o).intersect(e[o]); let i; i = "q" === t ? s : "k" === t ? s.reversed() : T.fromSquare(t.charCodeAt(0) - "a".charCodeAt(0)).intersect(s); for (const r of i) { if (e.king.has(r) && !e.promoted.has(r)) break; if (e.rook.has(r)) { n = n.with(r); break } } } return B.ok(n) } function Ie(e) { const t = e.split("+"); if (3 === t.length && "" === t[0]) { const e = Oe(t[1]), n = Oe(t[2]); return !V(e) || e > 3 || !V(n) || n > 3 ? B.err(new Re(Ae.RemainingChecks)) : B.ok(new I(3 - e, 3 - n)) } if (2 === t.length) { const e = Oe(t[0]), n = Oe(t[1]); return !V(e) || e > 3 || !V(n) || n > 3 ? B.err(new Re(Ae.RemainingChecks)) : B.ok(new I(e, n)) } return B.err(new Re(Ae.RemainingChecks)) } function Le(e) { const t = e.split(" "), n = t.shift(); let r, o, s = B.ok(void 0); if (n.endsWith("]")) { const e = n.indexOf("["); if (-1 === e) return B.err(new Re(Ae.Fen)); r = Ke(n.substr(0, e)), s = Fe(n.substr(e + 1, n.length - 1 - e - 1)) } else { const e = function (e, t, n) { let r = e.indexOf(t); for (; n-- > 0 && -1 !== r;)r = e.indexOf(t, r + t.length); return r }(n, "/", 7); -1 === e ? r = Ke(n) : (r = Ke(n.substr(0, e)), s = Fe(n.substr(e + 1))) } const i = t.shift(); if (V(i) && "w" !== i) { if ("b" !== i) return B.err(new Re(Ae.Turn)); o = "black" } else o = "white"; return r.chain((e => { const n = t.shift(), r = V(n) ? Ne(e, n) : B.ok(T.empty()), i = t.shift(); let a; if (V(i) && "-" !== i && (a = function (e) { if (2 !== e.length) return; const t = e.charCodeAt(0) - "a".charCodeAt(0), n = e.charCodeAt(1) - "1".charCodeAt(0); return t < 0 || t >= 8 || n < 0 || n >= 8 ? void 0 : t + 8 * n }(i), !V(a))) return B.err(new Re(Ae.EpSquare)); let c, u = t.shift(); V(u) && u.includes("+") && (c = Ie(u), u = t.shift()); const h = V(u) ? Oe(u) : 0; if (!V(h)) return B.err(new Re(Ae.Halfmoves)); const l = t.shift(), d = V(l) ? Oe(l) : 1; if (!V(d)) return B.err(new Re(Ae.Fullmoves)); const p = t.shift(); let f = B.ok(void 0); if (V(p)) { if (V(c)) return B.err(new Re(Ae.RemainingChecks)); f = Ie(p) } else V(c) && (f = c); return t.length > 0 ? B.err(new Re(Ae.Fen)) : s.chain((t => r.chain((n => f.map((r => ({ board: e, pockets: t, turn: o, unmovedRooks: n, remainingChecks: r, epSquare: a, halfmoves: h, fullmoves: Math.max(1, d) }))))))) })) } function Be(e, t) { let n = W(e.role); return "white" === e.color && (n = n.toUpperCase()), (null == t ? void 0 : t.promoted) && e.promoted && (n += "~"), n } function De(e, t) { let n = "", r = 0; for (let o = 7; o >= 0; o--)for (let s = 0; s < 8; s++) { const i = s + 8 * o, a = e.get(i); a ? (r > 0 && (n += r, r = 0), n += Be(a, t)) : r++, 7 === s && (r > 0 && (n += r, r = 0), 0 !== o && (n += "/")) } return n } function ze(e) { return x.map((t => W(t).repeat(e[t]))).join("") } function _e(e, t, n) { const r = null == n ? void 0 : n.shredder; let o = ""; for (const s of q) { const n = T.backrank(s), i = e.kingOf(s); if (!V(i) || !n.has(i)) continue; const a = e.pieces(s, "rook").intersect(n); for (const e of t.intersect(a).reversed()) if (!r && e === a.first() && e < i) o += "white" === s ? "Q" : "q"; else if (!r && e === a.last() && i < e) o += "white" === s ? "K" : "k"; else { const t = S[Q(e)]; o += "white" === s ? t.toUpperCase() : t } } return o || "-" } function Ve(e, t) { return [De(e.board, t) + (e.pockets ? `[${o = e.pockets, ze(o.white).toUpperCase() + ze(o.black)}]` : ""), e.turn[0], _e(e.board, e.unmovedRooks, t), V(e.epSquare) ? (r = e.epSquare, S[Q(r)] + E[H(r)]) : "-", ...e.remainingChecks ? [(n = e.remainingChecks, `${n.white}+${n.black}`)] : [], ...(null == t ? void 0 : t.epd) ? [] : [Math.max(0, Math.min(e.halfmoves, 9999)), Math.max(1, Math.min(e.fullmoves, 9999))]].join(" "); var n, r, o } function $e(e) { switch (e) { case "chess": return "standard"; case "3check": return "threeCheck"; case "kingofthehill": return "kingOfTheHill"; case "racingkings": return "racingKings"; default: return e } } const je = e => void 0 !== e; class He { constructor(e, t) { this.cfg = e, this.options = e.options || {}, this.trans = lichess.trans(this.cfg.i18n), this.selected = (e => { let t = e; return function (e) { return je(e) && (t = e), t } })("pointer"), this.extraPositions = [{ fen: Me, epd: xe, name: this.trans("startPosition") }, { fen: "prompt", name: this.trans("loadPosition") }], e.positions && e.positions.forEach((e => e.epd = e.fen.split(" ").splice(0, 4).join(" "))), e.endgamePositions && e.endgamePositions.forEach((e => e.epd = e.fen.split(" ").splice(0, 4).join(" "))), window.Mousetrap.bind("f", (() => { this.chessground && this.chessground.toggleOrientation(), t() })), this.castlingToggles = { K: !1, Q: !1, k: !1, q: !1 }; const n = new URLSearchParams(location.search); this.rules = "chess", this.initialFen = (e.fen || n.get("fen") || Me).replace(/_/g, " "), this.redraw = () => { }, this.setFen(this.initialFen), this.redraw = t } onChange() { var e, t; const n = this.getFen(); if (!this.cfg.embed) { const e = new URLSearchParams; n === Me && "chess" === this.rules || e.set("fen", n), "chess" !== this.rules && e.set("variant", $e(this.rules)); const t = e.toString(); window.history.replaceState(null, "", "/analysis" + (t ? "?" + t : "")) } null === (t = (e = this.options).onChange) || void 0 === t || t.call(e, n), this.redraw() } castlingToggleFen() { let e = ""; for (const t of C) this.castlingToggles[t] && (e += t); return e } getSetup() { var e; const t = Le((null === (e = this.chessground) || void 0 === e ? void 0 : e.getFen()) || this.initialFen).unwrap((e => e.board), (e => K.empty())); return { board: t, pockets: this.pockets, turn: this.turn, unmovedRooks: this.unmovedRooks || Ne(t, this.castlingToggleFen()).unwrap(), epSquare: this.epSquare, remainingChecks: this.remainingChecks, halfmoves: this.halfmoves, fullmoves: this.fullmoves } } getFen() { return Ve(this.getSetup(), { promoted: "crazyhouse" == this.rules }) } getTurn() { return this.turn } getLegalFen() { return qe(this.rules, this.getSetup()).unwrap((e => Ve(e.toSetup(), { promoted: "crazyhouse" == e.rules })), (e => { })) } isPlayable() { return qe(this.rules, this.getSetup()).unwrap((e => !e.isEnd()), (e => !1)) } getState() { return { fen: this.getFen(), legalFen: this.getLegalFen(), playable: "chess" == this.rules && this.isPlayable() } } makeAnalysisUrl(e) { const t = "chess" === this.rules ? "" : $e(this.rules) + "/"; return this.makeUrl(`/analysis/${t}`, e) } makeUrl(e, t) { return e + encodeURIComponent(t).replace(/%20/g, "_").replace(/%2F/g, "/") } bottomColor() { return this.chessground ? this.chessground.state.orientation : this.options.orientation || "white" } setCastlingToggle(e, t) { this.castlingToggles[e] != t && (this.unmovedRooks = void 0), this.castlingToggles[e] = t, this.onChange() } setTurn(e) { this.turn = e, this.onChange() } startPosition() { this.setFen(Me) } clearBoard() { this.setFen(Pe) } loadNewFen(e) { ("prompt" !== e || (e = (prompt("Paste FEN position") || "").trim())) && this.setFen(e) } setFen(e) { return Le(e).unwrap((t => { this.chessground && this.chessground.set({ fen: e }), this.pockets = t.pockets, this.turn = t.turn, this.unmovedRooks = t.unmovedRooks, this.epSquare = t.epSquare, this.remainingChecks = t.remainingChecks, this.halfmoves = t.halfmoves, this.fullmoves = t.fullmoves; const n = ge.fromSetup(t); return this.castlingToggles.K = je(n.rook.white.h), this.castlingToggles.Q = je(n.rook.white.a), this.castlingToggles.k = je(n.rook.black.h), this.castlingToggles.q = je(n.rook.black.a), this.onChange(), !0 }), (e => !1)) } setRules(e) { this.rules = e, "crazyhouse" != e ? this.pockets = void 0 : this.pockets || (this.pockets = N.empty()), "3check" != e ? this.remainingChecks = void 0 : this.remainingChecks || (this.remainingChecks = I.default()), this.onChange() } setOrientation(e) { this.options.orientation = e, this.chessground.state.orientation !== e && this.chessground.toggleOrientation(), this.redraw() } } const Qe = ["white", "black"], We = ["a", "b", "c", "d", "e", "f", "g", "h"], Ue = ["1", "2", "3", "4", "5", "6", "7", "8"], Xe = [...Ue].reverse(), Ye = Array.prototype.concat(...We.map((e => Ue.map((t => e + t))))), Ge = e => Ye[8 * e[0] + e[1]], Ze = e => [e.charCodeAt(0) - 97, e.charCodeAt(1) - 49], Je = Ye.map(Ze); const et = () => { let e; return { start() { e = performance.now() }, cancel() { e = void 0 }, stop() { if (!e) return 0; const t = performance.now() - e; return e = void 0, t } } }, tt = e => "white" === e ? "black" : "white", nt = (e, t) => { const n = e[0] - t[0], r = e[1] - t[1]; return n * n + r * r }, rt = (e, t) => e.role === t.role && e.color === t.color, ot = e => (t, n) => [(n ? t[0] : 7 - t[0]) * e.width / 8, (n ? 7 - t[1] : t[1]) * e.height / 8], st = (e, t) => { e.style.transform = `translate(${t[0]}px,${t[1]}px)` }, it = (e, t) => { e.style.visibility = t ? "visible" : "hidden" }, at = e => { var t; return e.clientX || 0 === e.clientX ? [e.clientX, e.clientY] : (null === (t = e.targetTouches) || void 0 === t ? void 0 : t[0]) ? [e.targetTouches[0].clientX, e.targetTouches[0].clientY] : void 0 }, ct = e => 2 === e.buttons || 2 === e.button, ut = (e, t) => { const n = document.createElement(e); return t && (n.className = t), n }; function ht(e, t, n) { const r = Ze(e); return t || (r[0] = 7 - r[0], r[1] = 7 - r[1]), [n.left + n.width * r[0] / 8 + n.width / 16, n.top + n.height * (7 - r[1]) / 8 + n.height / 16] } function lt(e, t) { return Math.abs(e - t) } const dt = (e, t, n, r) => { const o = lt(e, n), s = lt(t, r); return 1 === o && 2 === s || 2 === o && 1 === s }, pt = (e, t, n, r) => lt(e, n) === lt(t, r), ft = (e, t, n, r) => e === n || t === r, mt = (e, t, n, r) => pt(e, t, n, r) || ft(e, t, n, r); function gt(e, t, n) { const r = e.get(t); if (!r) return []; const o = Ze(t), s = r.role, i = "pawn" === s ? (a = r.color, (e, t, n, r) => lt(e, n) < 2 && ("white" === a ? r === t + 1 || t <= 1 && r === t + 2 && e === n : r === t - 1 || t >= 6 && r === t - 2 && e === n)) : "knight" === s ? dt : "bishop" === s ? pt : "rook" === s ? ft : "queen" === s ? mt : function (e, t, n) { return (r, o, s, i) => lt(r, s) < 2 && lt(o, i) < 2 || n && o === i && o === ("white" === e ? 0 : 7) && (4 === r && (2 === s && t.includes(0) || 6 === s && t.includes(7)) || t.includes(s)) }(r.color, function (e, t) { const n = "white" === t ? "1" : "8", r = []; for (const [o, s] of e) o[1] === n && s.color === t && "rook" === s.role && r.push(Ze(o)[0]); return r }(e, r.color), n); var a; return Je.filter((e => (o[0] !== e[0] || o[1] !== e[1]) && i(o[0], o[1], e[0], e[1]))).map(Ge) } function bt(e, ...t) { e && setTimeout((() => e(...t)), 1) } function vt(e) { e.premovable.current && (e.premovable.current = void 0, bt(e.premovable.events.unset)) } function kt(e) { const t = e.predroppable; t.current && (t.current = void 0, bt(t.events.unset)) } function wt(e, t, n) { const r = e.pieces.get(t), o = e.pieces.get(n); if (t === n || !r) return !1; const s = o && o.color !== r.color ? o : void 0; return n === e.selected && Mt(e), bt(e.events.move, t, n, s), function (e, t, n) { if (!e.autoCastle) return !1; const r = e.pieces.get(t); if (!r || "king" !== r.role) return !1; const o = Ze(t), s = Ze(n); if (0 !== o[1] && 7 !== o[1] || o[1] !== s[1]) return !1; 4 !== o[0] || e.pieces.has(n) || (6 === s[0] ? n = Ge([7, s[1]]) : 2 === s[0] && (n = Ge([0, s[1]]))); const i = e.pieces.get(n); return !(!i || i.color !== r.color || "rook" !== i.role || (e.pieces.delete(t), e.pieces.delete(n), o[0] < s[0] ? (e.pieces.set(Ge([6, s[1]]), r), e.pieces.set(Ge([5, s[1]]), i)) : (e.pieces.set(Ge([2, s[1]]), r), e.pieces.set(Ge([3, s[1]]), i)), 0)) }(e, t, n) || (e.pieces.set(n, r), e.pieces.delete(t)), e.lastMove = [t, n], e.check = void 0, bt(e.events.change), s || !0 } function yt(e, t, n, r) { if (e.pieces.has(n)) { if (!r) return !1; e.pieces.delete(n) } return bt(e.events.dropNewPiece, t, n), e.pieces.set(n, t), e.lastMove = [n], e.check = void 0, bt(e.events.change), e.movable.dests = void 0, e.turnColor = tt(e.turnColor), !0 } function Ct(e, t, n) { const r = wt(e, t, n); return r && (e.movable.dests = void 0, e.turnColor = tt(e.turnColor), e.animation.current = void 0), r } function St(e, t, n) { if (At(e, t, n)) { const r = Ct(e, t, n); if (r) { const o = e.hold.stop(); Mt(e); const s = { premove: !1, ctrlKey: e.stats.ctrlKey, holdTime: o }; return !0 !== r && (s.captured = r), bt(e.movable.events.after, t, n, s), !0 } } else if (function (e, t, n) { return t !== n && Rt(e, t) && gt(e.pieces, t, e.premovable.castle).includes(n) }(e, t, n)) return function (e, t, n, r) { kt(e), e.premovable.current = [t, n], bt(e.premovable.events.set, t, n, r) }(e, t, n, { ctrlKey: e.stats.ctrlKey }), Mt(e), !0; return Mt(e), !1 } function Et(e, t, n, r) { const o = e.pieces.get(t); o && (function (e, t, n) { const r = e.pieces.get(t); return !(!r || t !== n && e.pieces.has(n) || "both" !== e.movable.color && (e.movable.color !== r.color || e.turnColor !== r.color)) }(e, t, n) || r) ? (e.pieces.delete(t), yt(e, o, n, r), bt(e.movable.events.afterNewPiece, o.role, n, { premove: !1, predrop: !1 })) : o && function (e, t, n) { const r = e.pieces.get(t), o = e.pieces.get(n); return !!r && (!o || o.color !== e.movable.color) && e.predroppable.enabled && ("pawn" !== r.role || "1" !== n[1] && "8" !== n[1]) && e.movable.color === r.color && e.turnColor !== r.color }(e, t, n) ? function (e, t, n) { vt(e), e.predroppable.current = { role: t, key: n }, bt(e.predroppable.events.set, t, n) }(e, o.role, n) : (vt(e), kt(e)), e.pieces.delete(t), Mt(e) } function qt(e, t, n) { if (bt(e.events.select, t), e.selected) { if (e.selected === t && !e.draggable.enabled) return Mt(e), void e.hold.cancel(); if ((e.selectable.enabled || n) && e.selected !== t && St(e, e.selected, t)) return void (e.stats.dragged = !1) } (Pt(e, t) || Rt(e, t)) && (xt(e, t), e.hold.start()) } function xt(e, t) { e.selected = t, Rt(e, t) ? e.premovable.dests = gt(e.pieces, t, e.premovable.castle) : e.premovable.dests = void 0 } function Mt(e) { e.selected = void 0, e.premovable.dests = void 0, e.hold.cancel() } function Pt(e, t) { const n = e.pieces.get(t); return !!n && ("both" === e.movable.color || e.movable.color === n.color && e.turnColor === n.color) } function At(e, t, n) { var r, o; return t !== n && Pt(e, t) && (e.movable.free || !!(null === (o = null === (r = e.movable.dests) || void 0 === r ? void 0 : r.get(t)) || void 0 === o ? void 0 : o.includes(n))) } function Rt(e, t) { const n = e.pieces.get(t); return !!n && e.premovable.enabled && e.movable.color === n.color && e.turnColor !== n.color } function Ot(e) { const t = e.premovable.current; if (!t) return !1; const n = t[0], r = t[1]; let o = !1; if (At(e, n, r)) { const t = Ct(e, n, r); if (t) { const s = { premove: !0 }; !0 !== t && (s.captured = t), bt(e.movable.events.after, n, r, s), o = !0 } } return vt(e), o } function Tt(e) { vt(e), kt(e), Mt(e) } function Kt(e) { e.movable.color = e.movable.dests = e.animation.current = void 0, Tt(e) } function Ft(e, t, n) { let r = Math.floor(8 * (e[0] - n.left) / n.width); t || (r = 7 - r); let o = 7 - Math.floor(8 * (e[1] - n.top) / n.height); return t || (o = 7 - o), r >= 0 && r < 8 && o >= 0 && o < 8 ? Ge([r, o]) : void 0 } function Nt(e) { return "white" === e.orientation } const It = ["green", "red", "blue", "yellow"]; function Lt(e, t) { if (t.touches && t.touches.length > 1) return; t.stopPropagation(), t.preventDefault(), t.ctrlKey ? Mt(e) : Tt(e); const n = at(t), r = Ft(n, Nt(e), e.dom.bounds()); r && (e.drawable.current = { orig: r, pos: n, brush: Vt(t), snapToValidMove: e.drawable.defaultSnapToValidMove }, Bt(e)) } function Bt(e) { requestAnimationFrame((() => { const t = e.drawable.current; if (t) { const n = Ft(t.pos, Nt(e), e.dom.bounds()); n || (t.snapToValidMove = !1); const r = t.snapToValidMove ? function (e, t, n, r) { const o = Ze(e), s = Je.filter((e => mt(o[0], o[1], e[0], e[1]) || dt(o[0], o[1], e[0], e[1]))), i = s.map((e => ht(Ge(e), n, r))).map((e => nt(t, e))), [, a] = i.reduce(((e, t, n) => e[0] < t ? e : [t, n]), [i[0], 0]); return Ge(s[a]) }(t.orig, t.pos, Nt(e), e.dom.bounds()) : n; r !== t.mouseSq && (t.mouseSq = r, t.dest = r !== t.orig ? r : void 0, e.dom.redrawNow()), Bt(e) } })) } function Dt(e, t) { e.drawable.current && (e.drawable.current.pos = at(t)) } function zt(e) { const t = e.drawable.current; t && (t.mouseSq && function (e, t) { const n = e => e.orig === t.orig && e.dest === t.dest, r = e.shapes.find(n); r && (e.shapes = e.shapes.filter((e => !n(e)))); r && r.brush === t.brush || e.shapes.push(t); $t(e) }(e.drawable, t), _t(e)) } function _t(e) { e.drawable.current && (e.drawable.current = void 0, e.dom.redraw()) } function Vt(e) { var t; const n = (e.shiftKey || e.ctrlKey) && ct(e), r = e.altKey || e.metaKey || (null === (t = e.getModifierState) || void 0 === t ? void 0 : t.call(e, "AltGraph")); return It[(n ? 1 : 0) + (r ? 2 : 0)] } function $t(e) { e.onChange && e.onChange(e.shapes) } function jt(e, t) { return t.animation.enabled ? function (e, t) { const n = new Map(t.pieces), r = e(t), o = function (e, t) { const n = new Map, r = [], o = new Map, s = [], i = [], a = new Map; let c, u, h; for (const [l, d] of e) a.set(l, Qt(l, d)); for (const l of Ye) c = t.pieces.get(l), u = a.get(l), c ? u ? rt(c, u.piece) || (s.push(u), i.push(Qt(l, c))) : i.push(Qt(l, c)) : u && s.push(u); for (const l of i) u = Wt(l, s.filter((e => rt(l.piece, e.piece)))), u && (h = [u.pos[0] - l.pos[0], u.pos[1] - l.pos[1]], n.set(l.key, h.concat(h)), r.push(u.key)); for (const l of s) r.includes(l.key) || o.set(l.key, l.piece); return { anims: n, fadings: o } }(n, t); if (o.anims.size || o.fadings.size) { const e = t.animation.current && t.animation.current.start; t.animation.current = { start: performance.now(), frequency: 1 / t.animation.duration, plan: o }, e || Ut(t, performance.now()) } else t.dom.redraw(); return r }(e, t) : Ht(e, t) } function Ht(e, t) { const n = e(t); return t.dom.redraw(), n } function Qt(e, t) { return { key: e, pos: Ze(e), piece: t } } function Wt(e, t) { return t.sort(((t, n) => nt(e.pos, t.pos) - nt(e.pos, n.pos)))[0] } function Ut(e, t) { const n = e.animation.current; if (void 0 === n) return void (e.dom.destroyed || e.dom.redrawNow()); const r = 1 - (t - n.start) * n.frequency; if (r <= 0) e.animation.current = void 0, e.dom.redrawNow(); else { const t = function (e) { return e < .5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1 }(r); for (const e of n.plan.anims.values()) e[2] = e[0] * t, e[3] = e[1] * t; e.dom.redrawNow(!0), requestAnimationFrame(((t = performance.now()) => Ut(e, t))) } } function Xt(e, t) { if (!t.isTrusted || void 0 !== t.button && 0 !== t.button) return; if (t.touches && t.touches.length > 1) return; const n = e.dom.bounds(), r = at(t), o = Ft(r, Nt(e), n); if (!o) return; const s = e.pieces.get(o), i = e.selected; var a; i || !e.drawable.enabled || !e.drawable.eraseOnClick && s && s.color === e.turnColor || (a = e).drawable.shapes.length && (a.drawable.shapes = [], a.dom.redraw(), $t(a.drawable)), !1 !== t.cancelable && (!t.touches || e.blockTouchScroll || s || i || function (e, t) { const n = Nt(e), r = e.dom.bounds(), o = Math.pow(r.width / 8, 2); for (const s of e.pieces.keys()) { const e = ht(s, n, r); if (nt(e, t) <= o) return !0 } return !1 }(e, r)) && t.preventDefault(); const c = !!e.premovable.current, u = !!e.predroppable.current; e.stats.ctrlKey = t.ctrlKey, e.selected && At(e, e.selected, o) ? jt((e => qt(e, o)), e) : qt(e, o); const h = e.selected === o, l = nn(e, o); if (s && l && h && function (e, t) { const n = e.pieces.get(t); return !!n && e.draggable.enabled && ("both" === e.movable.color || e.movable.color === n.color && (e.turnColor === n.color || e.premovable.enabled)) }(e, o)) { e.draggable.current = { orig: o, piece: s, origPos: r, pos: r, started: e.draggable.autoDistance && e.stats.dragged, element: l, previouslySelected: i, originTarget: t.target, keyHasChanged: !1 }, l.cgDragging = !0, l.classList.add("dragging"); const a = e.dom.elements.ghost; a && (a.className = `ghost ${s.color} ${s.role}`, st(a, ot(n)(Ze(o), Nt(e))), it(a, !0)), Gt(e) } else c && vt(e), u && kt(e); e.dom.redraw() } function Yt(e, t, n, r) { const o = "a0"; e.pieces.set(o, t), e.dom.redraw(); const s = at(n); e.draggable.current = { orig: o, piece: t, origPos: s, pos: s, started: !0, element: () => nn(e, o), originTarget: n.target, newPiece: !0, force: !!r, keyHasChanged: !1 }, Gt(e) } function Gt(e) { requestAnimationFrame((() => { var t; const n = e.draggable.current; if (!n) return; (null === (t = e.animation.current) || void 0 === t ? void 0 : t.plan.anims.has(n.orig)) && (e.animation.current = void 0); const r = e.pieces.get(n.orig); if (r && rt(r, n.piece)) { if (!n.started && nt(n.pos, n.origPos) >= Math.pow(e.draggable.distance, 2) && (n.started = !0), n.started) { if ("function" == typeof n.element) { const e = n.element(); if (!e) return; e.cgDragging = !0, e.classList.add("dragging"), n.element = e } const t = e.dom.bounds(); st(n.element, [n.pos[0] - t.left - t.width / 16, n.pos[1] - t.top - t.height / 16]), n.keyHasChanged || (n.keyHasChanged = n.orig !== Ft(n.pos, Nt(e), t)) } } else en(e); Gt(e) })) } function Zt(e, t) { e.draggable.current && (!t.touches || t.touches.length < 2) && (e.draggable.current.pos = at(t)) } function Jt(e, t) { const n = e.draggable.current; if (!n) return; if ("touchend" === t.type && !1 !== t.cancelable && t.preventDefault(), "touchend" === t.type && n.originTarget !== t.target && !n.newPiece) return void (e.draggable.current = void 0); vt(e), kt(e); const r = Ft(at(t) || n.pos, Nt(e), e.dom.bounds()); r && n.started && n.orig !== r ? n.newPiece ? Et(e, n.orig, r, n.force) : (e.stats.ctrlKey = t.ctrlKey, St(e, n.orig, r) && (e.stats.dragged = !0)) : n.newPiece ? e.pieces.delete(n.orig) : e.draggable.deleteOnDropOff && !r && (e.pieces.delete(n.orig), bt(e.events.change)), (n.orig !== n.previouslySelected && !n.keyHasChanged || n.orig !== r && r) && e.selectable.enabled || Mt(e), tn(e), e.draggable.current = void 0, e.dom.redraw() } function en(e) { const t = e.draggable.current; t && (t.newPiece && e.pieces.delete(t.orig), e.draggable.current = void 0, Mt(e), tn(e), e.dom.redraw()) } function tn(e) { const t = e.dom.elements; t.ghost && it(t.ghost, !1) } function nn(e, t) { let n = e.dom.elements.board.firstChild; for (; n;) { if (n.cgKey === t && "PIECE" === n.tagName) return n; n = n.nextSibling } } const rn = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR", on = { p: "pawn", r: "rook", n: "knight", b: "bishop", q: "queen", k: "king" }, sn = { pawn: "p", rook: "r", knight: "n", bishop: "b", queen: "q", king: "k" }; function an(e) { "start" === e && (e = rn); const t = new Map; let n = 7, r = 0; for (const o of e) switch (o) { case " ": return t; case "/": if (--n, n < 0) return t; r = 0; break; case "~": { const e = t.get(Ge([r, n])); e && (e.promoted = !0); break } default: { const e = o.charCodeAt(0); if (e < 57) r += e - 48; else { const e = o.toLowerCase(); t.set(Ge([r, n]), { role: on[e], color: o === e ? "black" : "white" }), ++r } } }return t } function cn(e, t) { t.animation && (hn(e.animation, t.animation), (e.animation.duration || 0) < 70 && (e.animation.enabled = !1)) } function un(e, t) { var n, r; if ((null === (n = t.movable) || void 0 === n ? void 0 : n.dests) && (e.movable.dests = void 0), (null === (r = t.drawable) || void 0 === r ? void 0 : r.autoShapes) && (e.drawable.autoShapes = []), hn(e, t), t.fen && (e.pieces = an(t.fen), e.drawable.shapes = []), "check" in t && function (e, t) { if (e.check = void 0, !0 === t && (t = e.turnColor), t) for (const [n, r] of e.pieces) "king" === r.role && r.color === t && (e.check = n) }(e, t.check || !1), "lastMove" in t && !t.lastMove ? e.lastMove = void 0 : t.lastMove && (e.lastMove = t.lastMove), e.selected && xt(e, e.selected), cn(e, t), !e.movable.rookCastle && e.movable.dests) { const t = "white" === e.movable.color ? "1" : "8", n = "e" + t, r = e.movable.dests.get(n), o = e.pieces.get(n); if (!r || !o || "king" !== o.role) return; e.movable.dests.set(n, r.filter((e => !(e === "a" + t && r.includes("c" + t) || e === "h" + t && r.includes("g" + t))))) } } function hn(e, t) { for (const n in t) ln(e[n]) && ln(t[n]) ? hn(e[n], t[n]) : e[n] = t[n] } function ln(e) { return "object" == typeof e } function dn(e, t) { e.exploding && (t ? e.exploding.stage = t : e.exploding = void 0, e.dom.redraw()) } function pn(e, t) { function n() { !function (e) { e.orientation = tt(e.orientation), e.animation.current = e.draggable.current = e.selected = void 0 }(e), t() } return { set(t) { t.orientation && t.orientation !== e.orientation && n(), cn(e, t), (t.fen ? jt : Ht)((e => un(e, t)), e) }, state: e, getFen: () => { return t = e.pieces, Xe.map((e => We.map((n => { const r = t.get(n + e); if (r) { const e = sn[r.role]; return "white" === r.color ? e.toUpperCase() : e } return "1" })).join(""))).join("/").replace(/1{2,}/g, (e => e.length.toString())); var t }, toggleOrientation: n, setPieces(t) { jt((e => function (e, t) { for (const [n, r] of t) r ? e.pieces.set(n, r) : e.pieces.delete(n) }(e, t)), e) }, selectSquare(t, n) { t ? jt((e => qt(e, t, n)), e) : e.selected && (Mt(e), e.dom.redraw()) }, move(t, n) { jt((e => wt(e, t, n)), e) }, newPiece(t, n) { jt((e => yt(e, t, n)), e) }, playPremove() { if (e.premovable.current) { if (jt(Ot, e)) return !0; e.dom.redraw() } return !1 }, playPredrop(t) { if (e.predroppable.current) { const n = function (e, t) { const n = e.predroppable.current; let r = !1; if (!n) return !1; t(n) && yt(e, { role: n.role, color: e.movable.color }, n.key) && (bt(e.movable.events.afterNewPiece, n.role, n.key, { premove: !1, predrop: !0 }), r = !0); return kt(e), r }(e, t); return e.dom.redraw(), n } return !1 }, cancelPremove() { Ht(vt, e) }, cancelPredrop() { Ht(kt, e) }, cancelMove() { Ht((e => { Tt(e), en(e) }), e) }, stop() { Ht((e => { Kt(e), en(e) }), e) }, explode(t) { !function (e, t) { e.exploding = { stage: 1, keys: t }, e.dom.redraw(), setTimeout((() => { dn(e, 2), setTimeout((() => dn(e, void 0)), 120) }), 120) }(e, t) }, setAutoShapes(t) { Ht((e => e.drawable.autoShapes = t), e) }, setShapes(t) { Ht((e => e.drawable.shapes = t), e) }, getKeyAtDomPos: t => Ft(t, Nt(e), e.dom.bounds()), redrawAll: t, dragNewPiece(t, n, r) { Yt(e, t, n, r) }, destroy() { Kt(e), e.dom.unbind && e.dom.unbind(), e.dom.destroyed = !0 } } } function fn(e) { return document.createElementNS("http://www.w3.org/2000/svg", e) } function mn(e, t, n) { const r = e.drawable, o = r.current, s = o && o.mouseSq ? o : void 0, i = new Map, a = e.dom.bounds(); for (const p of r.shapes.concat(r.autoShapes).concat(s ? [s] : [])) p.dest && i.set(p.dest, (i.get(p.dest) || 0) + 1); const c = r.shapes.concat(r.autoShapes).map((e => ({ shape: e, current: !1, hash: bn(e, i, !1, a) }))); s && c.push({ shape: s, current: !0, hash: bn(s, i, !0, a) }); const u = c.map((e => e.hash)).join(";"); if (u === e.drawable.prevSvgHash) return; e.drawable.prevSvgHash = u; const h = t.querySelector("defs"), l = t.querySelector("g"), d = n.querySelector("g"); !function (e, t, n) { const r = new Map; let o; for (const a of t) a.shape.dest && (o = e.brushes[a.shape.brush], a.shape.modifiers && (o = En(o, a.shape.modifiers)), r.set(o.key, o)); const s = new Set; let i = n.firstChild; for (; i;)s.add(i.getAttribute("cgKey")), i = i.nextSibling; for (const [a, c] of r.entries()) s.has(a) || n.appendChild(yn(c)) }(r, c, h), gn(e, c.filter((e => !e.shape.customSvg)), r.brushes, i, l), gn(e, c.filter((e => e.shape.customSvg)), r.brushes, i, d) } function gn(e, t, n, r, o) { const s = e.dom.bounds(), i = new Map, a = []; for (const h of t) i.set(h.hash, !1); let c, u = o.firstChild; for (; u;)c = u.getAttribute("cgHash"), i.has(c) ? i.set(c, !0) : a.push(u), u = u.nextSibling; for (const h of a) o.removeChild(h); for (const h of t) i.get(h.hash) || o.appendChild(wn(e, h, n, r, s)) } function bn({ orig: e, dest: t, brush: n, piece: r, modifiers: o, customSvg: s }, i, a, c) { return [c.width, c.height, a, e, t, n, t && (i.get(t) || 0) > 1, r && vn(r), o && (u = o, "" + (u.lineWidth || "")), s && kn(s)].filter((e => e)).join(","); var u } function vn(e) { return [e.color, e.role, e.scale].filter((e => e)).join(",") } function kn(e) { let t = 0; for (let n = 0; n < e.length; n++)t = (t << 5) - t + e.charCodeAt(n) >>> 0; return "custom-" + t.toString() } function wn(e, { shape: t, current: n, hash: r }, o, s, i) { let a; if (t.customSvg) { const n = Sn(Ze(t.orig), e.orientation); a = function (e, t, n) { const [r, o] = Mn(t, n), s = Cn(fn("g"), { transform: `translate(${r},${o})` }), i = Cn(fn("svg"), { width: 1, height: 1, viewBox: "0 0 100 100" }); return s.appendChild(i), i.innerHTML = e, s }(t.customSvg, n, i) } else if (t.piece) a = function (e, t, n, r) { const o = Mn(t, r), s = n.color[0] + ("knight" === n.role ? "n" : n.role[0]).toUpperCase(); return Cn(fn("image"), { className: `${n.role} ${n.color}`, x: o[0] - .5, y: o[1] - .5, width: 1, height: 1, href: e + s + ".svg", transform: `scale(${n.scale || 1})`, "transform-origin": `${o[0]} ${o[1]}` }) }(e.drawable.pieces.baseUrl, Sn(Ze(t.orig), e.orientation), t.piece, i); else { const r = Sn(Ze(t.orig), e.orientation); if (t.dest) { let c = o[t.brush]; t.modifiers && (c = En(c, t.modifiers)), a = function (e, t, n, r, o, s) { const i = function (e) { return (e ? 20 : 10) / 64 }(o && !r), a = Mn(t, s), c = Mn(n, s), u = c[0] - a[0], h = c[1] - a[1], l = Math.atan2(h, u), d = Math.cos(l) * i, p = Math.sin(l) * i; return Cn(fn("line"), { stroke: e.color, "stroke-width": qn(e, r), "stroke-linecap": "round", "marker-end": "url(#arrowhead-" + e.key + ")", opacity: xn(e, r), x1: a[0], y1: a[1], x2: c[0] - d, y2: c[1] - p }) }(c, r, Sn(Ze(t.dest), e.orientation), n, (s.get(t.dest) || 0) > 1, i) } else a = function (e, t, n, r) { const o = Mn(t, r), s = [3 / 64, 4 / 64], i = (r.width + r.height) / (4 * Math.max(r.width, r.height)); return Cn(fn("circle"), { stroke: e.color, "stroke-width": s[n ? 0 : 1], fill: "none", opacity: xn(e, n), cx: o[0], cy: o[1], r: i - s[1] / 2 }) }(o[t.brush], r, n, i) } return a.setAttribute("cgHash", r), a } function yn(e) { const t = Cn(fn("marker"), { id: "arrowhead-" + e.key, orient: "auto", markerWidth: 4, markerHeight: 8, refX: 2.05, refY: 2.01 }); return t.appendChild(Cn(fn("path"), { d: "M0,0 V4 L3,2 Z", fill: e.color })), t.setAttribute("cgKey", e.key), t } function Cn(e, t) { for (const n in t) e.setAttribute(n, t[n]); return e } function Sn(e, t) { return "white" === t ? e : [7 - e[0], 7 - e[1]] } function En(e, t) { return { color: e.color, opacity: Math.round(10 * e.opacity) / 10, lineWidth: Math.round(t.lineWidth || e.lineWidth), key: [e.key, t.lineWidth].filter((e => e)).join("") } } function qn(e, t) { return (e.lineWidth || 10) * (t ? .85 : 1) / 64 } function xn(e, t) { return (e.opacity || 1) * (t ? .9 : 1) } function Mn(e, t) { const n = Math.min(1, t.width / t.height), r = Math.min(1, t.height / t.width); return [(e[0] - 3.5) * n, (3.5 - e[1]) * r] } function Pn(e, t) { const n = ut("coords", t); let r; for (const o of e) r = ut("coord"), r.textContent = o, n.appendChild(r); return n } function An(e, t) { const n = e.dom.elements.board; if ("ResizeObserver" in window && new ResizeObserver(t).observe(e.dom.elements.wrap), e.viewOnly) return; const r = function (e) { return t => { e.draggable.current ? en(e) : e.drawable.current ? _t(e) : t.shiftKey || ct(t) ? e.drawable.enabled && Lt(e, t) : e.viewOnly || (e.dropmode.active ? function (e, t) { if (!e.dropmode.active) return; vt(e), kt(e); const n = e.dropmode.piece; if (n) { e.pieces.set("a0", n); const r = at(t), o = r && Ft(r, Nt(e), e.dom.bounds()); o && Et(e, "a0", o) } e.dom.redraw() }(e, t) : Xt(e, t)) } }(e); n.addEventListener("touchstart", r, { passive: !1 }), n.addEventListener("mousedown", r, { passive: !1 }), (e.disableContextMenu || e.drawable.enabled) && n.addEventListener("contextmenu", (e => e.preventDefault())) } function Rn(e, t, n, r) { return e.addEventListener(t, n, r), () => e.removeEventListener(t, n, r) } function On(e, t, n) { return r => { e.drawable.current ? e.drawable.enabled && n(e, r) : e.viewOnly || t(e, r) } } function Tn(e) { const t = Nt(e), n = ot(e.dom.bounds()), r = e.dom.elements.board, o = e.pieces, s = e.animation.current, i = s ? s.plan.anims : new Map, a = s ? s.plan.fadings : new Map, c = e.draggable.current, u = function (e) { var t; const n = new Map; if (e.lastMove && e.highlight.lastMove) for (const s of e.lastMove) Dn(n, s, "last-move"); e.check && e.highlight.check && Dn(n, e.check, "check"); if (e.selected && (Dn(n, e.selected, "selected"), e.movable.showDests)) { const r = null === (t = e.movable.dests) || void 0 === t ? void 0 : t.get(e.selected); if (r) for (const t of r) Dn(n, t, "move-dest" + (e.pieces.has(t) ? " oc" : "")); const o = e.premovable.dests; if (o) for (const t of o) Dn(n, t, "premove-dest" + (e.pieces.has(t) ? " oc" : "")) } const r = e.premovable.current; if (r) for (const s of r) Dn(n, s, "current-premove"); else e.predroppable.current && Dn(n, e.predroppable.current.key, "current-premove"); const o = e.exploding; if (o) for (const s of o.keys) Dn(n, s, "exploding" + o.stage); return n }(e), h = new Set, l = new Set, d = new Map, p = new Map; let f, m, g, b, v, k, w, y, C, S; for (m = r.firstChild; m;) { if (f = m.cgKey, Fn(m)) if (g = o.get(f), v = i.get(f), k = a.get(f), b = m.cgPiece, !m.cgDragging || c && c.orig === f || (m.classList.remove("dragging"), st(m, n(Ze(f), t)), m.cgDragging = !1), !k && m.cgFading && (m.cgFading = !1, m.classList.remove("fading")), g) { if (v && m.cgAnimating && b === Bn(g)) { const e = Ze(f); e[0] += v[2], e[1] += v[3], m.classList.add("anim"), st(m, n(e, t)) } else m.cgAnimating && (m.cgAnimating = !1, m.classList.remove("anim"), st(m, n(Ze(f), t)), e.addPieceZIndex && (m.style.zIndex = Ln(Ze(f), t))); b !== Bn(g) || k && m.cgFading ? k && b === Bn(k) ? (m.classList.add("fading"), m.cgFading = !0) : zn(d, b, m) : h.add(f) } else zn(d, b, m); else if (Nn(m)) { const e = m.className; u.get(f) === e ? l.add(f) : zn(p, e, m) } m = m.nextSibling } for (const [E, q] of u) if (!l.has(E)) { C = p.get(q), S = C && C.pop(); const e = n(Ze(E), t); if (S) S.cgKey = E, st(S, e); else { const t = ut("square", q); t.cgKey = E, st(t, e), r.insertBefore(t, r.firstChild) } } for (const [E, q] of o) if (v = i.get(E), !h.has(E)) if (w = d.get(Bn(q)), y = w && w.pop(), y) { y.cgKey = E, y.cgFading && (y.classList.remove("fading"), y.cgFading = !1); const r = Ze(E); e.addPieceZIndex && (y.style.zIndex = Ln(r, t)), v && (y.cgAnimating = !0, y.classList.add("anim"), r[0] += v[2], r[1] += v[3]), st(y, n(r, t)) } else { const o = Bn(q), s = ut("piece", o), i = Ze(E); s.cgPiece = o, s.cgKey = E, v && (s.cgAnimating = !0, i[0] += v[2], i[1] += v[3]), st(s, n(i, t)), e.addPieceZIndex && (s.style.zIndex = Ln(i, t)), r.appendChild(s) } for (const E of d.values()) In(e, E); for (const E of p.values()) In(e, E) } function Kn(e) { const t = e.dom.elements.wrap.getBoundingClientRect(), n = e.dom.elements.container, r = t.height / t.width, o = 8 * Math.floor(t.width * window.devicePixelRatio / 8) / window.devicePixelRatio, s = o * r; n.style.width = o + "px", n.style.height = s + "px", e.dom.bounds.clear(), e.addDimensionsCssVars && (document.documentElement.style.setProperty("--cg-width", o + "px"), document.documentElement.style.setProperty("--cg-height", s + "px")) } function Fn(e) { return "PIECE" === e.tagName } function Nn(e) { return "SQUARE" === e.tagName } function In(e, t) { for (const n of t) e.dom.elements.board.removeChild(n) } function Ln(e, t) { let n = 3 + 8 * e[1] + (7 - e[0]); return t && (n = 69 - n), n + "" } function Bn(e) { return `${e.color} ${e.role}` } function Dn(e, t, n) { const r = e.get(t); r ? e.set(t, `${r} ${n}`) : e.set(t, n) } function zn(e, t, n) { const r = e.get(t); r ? r.push(n) : e.set(t, [n]) } function _n(e, t) { const n = { pieces: an(rn), orientation: "white", turnColor: "white", coordinates: !0, autoCastle: !0, viewOnly: !1, disableContextMenu: !1, addPieceZIndex: !1, addDimensionsCssVars: !1, blockTouchScroll: !1, pieceKey: !1, highlight: { lastMove: !0, check: !0 }, animation: { enabled: !0, duration: 200 }, movable: { free: !0, color: "both", showDests: !0, events: {}, rookCastle: !0 }, premovable: { enabled: !0, showDests: !0, castle: !0, events: {} }, predroppable: { enabled: !1, events: {} }, draggable: { enabled: !0, distance: 3, autoDistance: !0, showGhost: !0, deleteOnDropOff: !1 }, dropmode: { active: !1 }, selectable: { enabled: !0 }, stats: { dragged: !("ontouchstart" in window) }, events: {}, drawable: { enabled: !0, visible: !0, defaultSnapToValidMove: !0, eraseOnClick: !0, shapes: [], autoShapes: [], brushes: { green: { key: "g", color: "#15781B", opacity: 1, lineWidth: 10 }, red: { key: "r", color: "#882020", opacity: 1, lineWidth: 10 }, blue: { key: "b", color: "#003088", opacity: 1, lineWidth: 10 }, yellow: { key: "y", color: "#e68f00", opacity: 1, lineWidth: 10 }, paleBlue: { key: "pb", color: "#003088", opacity: .4, lineWidth: 15 }, paleGreen: { key: "pg", color: "#15781B", opacity: .4, lineWidth: 15 }, paleRed: { key: "pr", color: "#882020", opacity: .4, lineWidth: 15 }, paleGrey: { key: "pgr", color: "#4a4a4a", opacity: .35, lineWidth: 15 } }, pieces: { baseUrl: "https://lichess1.org/assets/piece/cburnett/" }, prevSvgHash: "" }, hold: et() }; function r() { const t = "dom" in n ? n.dom.unbind : void 0, r = function (e, t) { e.innerHTML = "", e.classList.add("cg-wrap"); for (const a of Qe) e.classList.toggle("orientation-" + a, t.orientation === a); e.classList.toggle("manipulable", !t.viewOnly); const n = ut("cg-container"); e.appendChild(n); const r = ut("cg-board"); let o, s, i; if (n.appendChild(r), t.drawable.visible && (o = Cn(fn("svg"), { class: "cg-shapes", viewBox: "-4 -4 8 8", preserveAspectRatio: "xMidYMid slice" }), o.appendChild(fn("defs")), o.appendChild(fn("g")), s = Cn(fn("svg"), { class: "cg-custom-svgs", viewBox: "-3.5 -3.5 8 8", preserveAspectRatio: "xMidYMid slice" }), s.appendChild(fn("g")), n.appendChild(o), n.appendChild(s)), t.coordinates) { const e = "black" === t.orientation ? " black" : ""; n.appendChild(Pn(Ue, "ranks" + e)), n.appendChild(Pn(We, "files" + e)) } return t.draggable.showGhost && (i = ut("piece", "ghost"), it(i, !1), n.appendChild(i)), { board: r, container: n, wrap: e, ghost: i, svg: o, customSvg: s } }(e, n), o = function (e) { let t; const n = () => (void 0 === t && (t = e()), t); return n.clear = () => { t = void 0 }, n }((() => r.board.getBoundingClientRect())), s = e => { Tn(a), !e && r.svg && mn(a, r.svg, r.customSvg) }, i = () => { Kn(a), function (e) { const t = Nt(e), n = ot(e.dom.bounds()); let r = e.dom.elements.board.firstChild; for (; r;)(Fn(r) && !r.cgAnimating || Nn(r)) && st(r, n(Ze(r.cgKey), t)), r = r.nextSibling }(a) }, a = n; return a.dom = { elements: r, bounds: o, redraw: Vn(s), redrawNow: s, unbind: t }, a.drawable.prevSvgHash = "", Kn(a), s(!1), An(a, i), t || (a.dom.unbind = function (e, t) { const n = []; if ("ResizeObserver" in window || n.push(Rn(document.body, "chessground.resize", t)), !e.viewOnly) { const t = On(e, Zt, Dt), r = On(e, Jt, zt); for (const e of ["touchmove", "mousemove"]) n.push(Rn(document, e, t)); for (const e of ["touchend", "mouseup"]) n.push(Rn(document, e, r)); const o = () => e.dom.bounds.clear(); n.push(Rn(document, "scroll", o, { capture: !0, passive: !0 })), n.push(Rn(window, "resize", o, { passive: !0 })) } return () => n.forEach((e => e())) }(a, i)), a.events.insert && a.events.insert(r), a } return un(n, t || {}), pn(r(), r) } function Vn(e) { let t = !1; return () => { t || (t = !0, requestAnimationFrame((() => { e(), t = !1 }))) } } function $n(e) { return l("div.cg-wrap", { hook: { insert: t => { const n = t.elm; e.chessground = _n(n, function (e) { return { fen: e.initialFen, orientation: e.options.orientation || "white", coordinates: !e.cfg.embed, autoCastle: !1, addPieceZIndex: e.cfg.is3d, movable: { free: !0, color: "both" }, animation: { duration: e.cfg.animation.duration }, premovable: { enabled: !1 }, drawable: { enabled: !0, defaultSnapToValidMove: "0" != (lichess.storage.get("arrow.snap") || 1) }, draggable: { showGhost: !0, deleteOnDropOff: !0 }, selectable: { enabled: !1 }, highlight: { lastMove: !1 }, events: { change: e.onChange.bind(e) } } }(e)), function (e, t) { const n = function (e) { return function (t) { const n = e.selected(); if ("pointer" === n || !1 === t.cancelable || "touchstart" !== t.type && "touchmove" !== t.type || t.preventDefault(), function (e) { return jn(e) && !e.ctrlKey }(t) || "touchstart" === t.type || "touchmove" === t.type) { if ("pointer" === n || e.chessground && e.chessground.state.draggable.current && e.chessground.state.draggable.current.newPiece) return; const r = at(t); if (!r) return; const o = e.chessground.getKeyAtDomPos(r); if (!o) return; if ("mousedown" !== t.type && "touchstart" !== t.type || (Hn = o), "trash" === n) Xn(e, o, t); else { const r = e.chessground.state.pieces.get(o), s = { color: n[0], role: n[1] }, i = r && s.color == r.color && s.role == r.role; if ("mousedown" !== t.type && "touchstart" !== t.type || !i) Wn || "mousedown" !== t.type && "touchstart" !== t.type && o === Qn || (e.chessground.setPieces(new Map([[o, s]])), e.onChange(), e.chessground.cancelMove()); else { Xn(e, o, t), Wn = !0; const n = { mousedown: "mouseup", touchstart: "touchend" }; document.addEventListener(n[t.type], (() => Wn = !1), { once: !0 }) } } Qn = o } else (function (e) { return ct(e) || !!e.ctrlKey && jn(e) })(t) && "pointer" !== n && (e.chessground.state.drawable.current = void 0, e.chessground.state.drawable.shapes = [], "contextmenu" === t.type && "trash" != n && (e.chessground.cancelMove(), n[0] = tt(n[0]), e.redraw())) } }(t);["touchstart", "touchmove", "mousedown", "mousemove", "contextmenu"].forEach((function (t) { e.addEventListener(t, n) })) }(n, e) }, destroy: t => e.chessground.destroy() } }) } function jn(e) { return 1 === e.buttons || 1 === e.button } let Hn, Qn, Wn, Un; function Xn(e, t, n) { "touchstart" === n.type ? (e.chessground.state.pieces.has(t) && (e.chessground.state.draggable.current.element.style.display = "none", e.chessground.cancelMove()), document.addEventListener("touchend", (() => Yn(e, t)), { once: !0 })) : "mousedown" !== n.type && t === Hn || Yn(e, t) } function Yn(e, t) { e.chessground.setPieces(new Map([[t, void 0]])), e.onChange() } function Gn(e, t, n, r) { const o = l("input", { attrs: { type: "checkbox" }, props: { checked: e.castlingToggles[t] }, on: { change(n) { e.setCastlingToggle(t, n.target.checked) } } }); return l("label", r ? [o, n] : [n, o]) } function Zn(e, t) { return l("optgroup", { attrs: { label: e } }, t) } function Jn(e, t) { const n = function (e) { return l("option", { attrs: { value: e.epd || e.fen, "data-fen": e.fen } }, e.eco ? `${e.eco} ${e.name}` : e.name) }; return l("div.board-editor__tools", [...!e.cfg.embed && e.cfg.positions && e.cfg.endgamePositions ? [l("div", [l("select.positions", { props: { value: t.fen.split(" ").slice(0, 4).join(" ") }, on: { change(t) { const n = t.target; let r = n.selectedOptions[0].getAttribute("data-fen"); "prompt" == r && (r = (prompt("Paste FEN") || "").trim()), r && e.setFen(r) || (n.value = "") } } }, [Zn(e.trans.noarg("setTheBoard"), [l("option", { attrs: { selected: !0 } }, `- ${e.trans.noarg("boardEditor")}  -`), ...e.extraPositions.map(n)]), Zn(e.trans.noarg("popularOpenings"), e.cfg.positions.map(n)), Zn(e.trans.noarg("endgamePositions"), e.cfg.endgamePositions.map((function (e) { return l("option", { attrs: { value: e.epd || e.fen, "data-fen": e.fen } }, e.name) })))])])] : [], l("div.metadata", [l("div.color", l("select", { on: { change(t) { e.setTurn(t.target.value) } }, props: { value: e.turn } }, ["whitePlays", "blackPlays"].map((function (t) { return l("option", { attrs: { value: "w" === t[0] ? "white" : "black", selected: t[0] === e.turn[0] } }, e.trans(t)) })))), l("div.castling", [l("strong", e.trans.noarg("castling")), l("div", [Gn(e, "K", e.trans.noarg("whiteCastlingKingside"), !!e.options.inlineCastling), Gn(e, "Q", "O-O-O", !0)]), l("div", [Gn(e, "k", e.trans.noarg("blackCastlingKingside"), !!e.options.inlineCastling), Gn(e, "q", "O-O-O", !0)])])]), ...e.cfg.embed ? [l("div.actions", [l("a.button.button-empty", { on: { click() { e.startPosition() } } }, e.trans.noarg("startPosition")), l("a.button.button-empty", { on: { click() { e.clearBoard() } } }, e.trans.noarg("clearBoard"))])] : [l("div.actions", [l("button.button.button-empty.text", { attrs: { "data-icon": "" }, on: { click() { e.setFen(Pe) } } }, e.trans.noarg("clearBoard")), l("button.button.button-empty.text", { attrs: { "data-icon": "" }, on: { click() { e.chessground.toggleOrientation(), e.redraw() } } }, e.trans.noarg("flipBoard"))]), l("div.continue-with.none", [l("a.button", { attrs: { href: "/?fen=" + t.legalFen + "#ai", rel: "nofollow" } }, e.trans.noarg("playWithTheMachine")), l("a.button", { attrs: { href: "/?fen=" + t.legalFen + "#friend", rel: "nofollow" } }, e.trans.noarg("playWithAFriend"))])]]) } function er(e, t) { if (!e.cfg.embed) return l("div.copyables", [l("p", [l("strong", "FEN"), l("input.copyable", { attrs: { spellcheck: !1 }, props: { value: t }, on: { change(t) { const n = t.target; e.setFen(n.value.trim()), n.reportValidity() }, input(e) { const t = e.target, n = Le(t.value.trim()).isOk; t.setCustomValidity(n ? "" : "Invalid FEN") }, blur(t) { const n = t.target; n.value = e.getFen(), n.setCustomValidity("") } } })])]) } function tr(e) { return "pointer" === e || "trash" === e ? e : e.join(" ") } function nr(e, t, n, r) { const o = tr(e.selected()), s = ["king", "queen", "rook", "bishop", "knight", "pawn"].map((function (e) { return [t, e] })); return l("div", { attrs: { class: ["spare", "spare-" + r, "spare-" + t].join(" ") } }, ["pointer", ...s, "trash"].map((t => { const n = tr(t), r = Object.assign({ class: n }, "pointer" !== t && "trash" !== t ? { "data-color": t[0], "data-role": t[1] } : {}); return l("div", { class: { "no-square": !0, pointer: "pointer" === t, trash: "trash" === t, "selected-square": !(o !== n || e.chessground && e.chessground.state.draggable.current && e.chessground.state.draggable.current.newPiece) }, on: { mousedown: rr(e, t, "mouseup"), touchstart: rr(e, t, "touchend"), touchmove: e => { Un = at(e) } } }, [l("div", [l("piece", { attrs: r })])]) }))) } function rr(e, t, n) { return function (r) { r.preventDefault(), "pointer" === t || "trash" === t ? (e.selected(t), e.redraw()) : (e.selected("pointer"), Yt(e.chessground.state, { color: t[0], role: t[1] }, r, !0), document.addEventListener(n, (n => { const r = at(n) || Un; r && e.chessground.getKeyAtDomPos(r) ? e.selected("pointer") : e.selected(t), e.redraw() }), { once: !0 })) } } function or(e) { if ("pointer" === e) return "pointer"; const t = "trash" === e ? "trash" : e.join("-"); return `url('${lichess.assetUrl("cursors/" + t + ".cur")}'), default !important` } function sr(e) { const t = e.getState(), n = e.bottomColor(); return l("div.board-editor", { attrs: { style: `cursor: ${or(e.selected())}` } }, [nr(e, tt(n), 0, "top"), l("div.main-board", [$n(e)]), nr(e, n, 0, "bottom"), Jn(e, t), er(e, t.fen)]) } const ir = function (h, l) { const d = { create: [], update: [], remove: [], destroy: [], pre: [], post: [] }, p = void 0 !== l ? l : e; for (const e of u) for (const t of h) { const n = t[e]; void 0 !== n && d[e].push(n) } function f(e) { const n = e.id ? "#" + e.id : "", r = e.getAttribute("class"), o = r ? "." + r.split(" ").join(".") : ""; return t(p.tagName(e).toLowerCase() + n + o, {}, [], void 0, e) } function m(e, t) { return function () { if (0 == --t) { const t = p.parentNode(e); p.removeChild(t, e) } } } function g(e, t) { var a, c; let u, h = e.data; if (void 0 !== h) { const t = null === (a = h.hook) || void 0 === a ? void 0 : a.init; s(t) && (t(e), h = e.data) } const l = e.children, f = e.sel; if ("!" === f) o(e.text) && (e.text = ""), e.elm = p.createComment(e.text); else if (void 0 !== f) { const o = f.indexOf("#"), a = f.indexOf(".", o), m = o > 0 ? o : f.length, b = a > 0 ? a : f.length, v = -1 !== o || -1 !== a ? f.slice(0, Math.min(m, b)) : f, k = e.elm = s(h) && s(u = h.ns) ? p.createElementNS(u, v, h) : p.createElement(v, h); for (m < b && k.setAttribute("id", f.slice(m + 1, b)), a > 0 && k.setAttribute("class", f.slice(b + 1).replace(/\./g, " ")), u = 0; u < d.create.length; ++u)d.create[u](i, e); if (n(l)) for (u = 0; u < l.length; ++u) { const e = l[u]; null != e && p.appendChild(k, g(e, t)) } else r(e.text) && p.appendChild(k, p.createTextNode(e.text)); const w = e.data.hook; s(w) && (null === (c = w.create) || void 0 === c || c.call(w, i, e), w.insert && t.push(e)) } else e.elm = p.createTextNode(e.text); return e.elm } function b(e, t, n, r, o, s) { for (; r <= o; ++r) { const o = n[r]; null != o && p.insertBefore(e, g(o, s), t) } } function v(e) { var t, n; const r = e.data; if (void 0 !== r) { null === (n = null === (t = null == r ? void 0 : r.hook) || void 0 === t ? void 0 : t.destroy) || void 0 === n || n.call(t, e); for (let t = 0; t < d.destroy.length; ++t)d.destroy[t](e); if (void 0 !== e.children) for (let t = 0; t < e.children.length; ++t) { const n = e.children[t]; null != n && "string" != typeof n && v(n) } } } function k(e, t, n, r) { for (var o, i; n <= r; ++n) { let r, a; const c = t[n]; if (null != c) if (s(c.sel)) { v(c), r = d.remove.length + 1, a = m(c.elm, r); for (let t = 0; t < d.remove.length; ++t)d.remove[t](c, a); const e = null === (i = null === (o = null == c ? void 0 : c.data) || void 0 === o ? void 0 : o.hook) || void 0 === i ? void 0 : i.remove; s(e) ? e(c, a) : a() } else p.removeChild(e, c.elm) } } function w(e, t, n) { var r, i, u, h, l; const f = null === (r = t.data) || void 0 === r ? void 0 : r.hook; null === (i = null == f ? void 0 : f.prepatch) || void 0 === i || i.call(f, e, t); const m = t.elm = e.elm, v = e.children, y = t.children; if (e !== t) { if (void 0 !== t.data) { for (let n = 0; n < d.update.length; ++n)d.update[n](e, t); null === (h = null === (u = t.data.hook) || void 0 === u ? void 0 : u.update) || void 0 === h || h.call(u, e, t) } o(t.text) ? s(v) && s(y) ? v !== y && function (e, t, n, r) { let s, i, u, h, l = 0, d = 0, f = t.length - 1, m = t[0], v = t[f], y = n.length - 1, C = n[0], S = n[y]; for (; l <= f && d <= y;)null == m ? m = t[++l] : null == v ? v = t[--f] : null == C ? C = n[++d] : null == S ? S = n[--y] : a(m, C) ? (w(m, C, r), m = t[++l], C = n[++d]) : a(v, S) ? (w(v, S, r), v = t[--f], S = n[--y]) : a(m, S) ? (w(m, S, r), p.insertBefore(e, m.elm, p.nextSibling(v.elm)), m = t[++l], S = n[--y]) : a(v, C) ? (w(v, C, r), p.insertBefore(e, v.elm, m.elm), v = t[--f], C = n[++d]) : (void 0 === s && (s = c(t, l, f)), i = s[C.key], o(i) ? p.insertBefore(e, g(C, r), m.elm) : (u = t[i], u.sel !== C.sel ? p.insertBefore(e, g(C, r), m.elm) : (w(u, C, r), t[i] = void 0, p.insertBefore(e, u.elm, m.elm))), C = n[++d]); (l <= f || d <= y) && (l > f ? (h = null == n[y + 1] ? null : n[y + 1].elm, b(e, h, n, d, y, r)) : k(e, t, l, f)) }(m, v, y, n) : s(y) ? (s(e.text) && p.setTextContent(m, ""), b(m, null, y, 0, y.length - 1, n)) : s(v) ? k(m, v, 0, v.length - 1) : s(e.text) && p.setTextContent(m, "") : e.text !== t.text && (s(v) && k(m, v, 0, v.length - 1), p.setTextContent(m, t.text)), null === (l = null == f ? void 0 : f.postpatch) || void 0 === l || l.call(f, e, t) } } return function (e, t) { let n, r, o; const s = []; for (n = 0; n < d.pre.length; ++n)d.pre[n](); for (function (e) { return void 0 !== e.sel }(e) || (e = f(e)), a(e, t) ? w(e, t, s) : (r = e.elm, o = p.parentNode(r), g(t, s), null !== o && (p.insertBefore(o, t.elm, p.nextSibling(r)), k(o, [e], 0, 0))), n = 0; n < s.length; ++n)s[n].data.hook.insert(s[n]); for (n = 0; n < d.post.length; ++n)d.post[n](); return t } }([m, p, y, k]); return window.Chessground = _n, function (e, t) { const n = new He(t, (function () { o = ir(o, sr(n)) })); e.innerHTML = ""; const r = document.createElement("div"); e.appendChild(r); let o = ir(r, sr(n)); return function () { if ("ontouchstart" in window) return; let e, t; const n = n => { e = n.pageX, t = n.pageY }; let r = {}; $("#topnav.hover").each((function () { const o = $(this).removeClass("hover"), s = () => o.toggleClass("hover"), i = () => { Math.sqrt((r.pX - e) * (r.pX - e) + (r.pY - t) * (r.pY - t)) < 8 ? (o.off(r.event, n), delete r.timeoutId, r.isActive = !0, s()) : (r.pX = e, r.pY = t, r.timeoutId = setTimeout(i, 200)) }, a = function (e) { r.timeoutId && (r.timeoutId = clearTimeout(r.timeoutId)); const t = r.event = "mousemove"; if ("mouseover" == e.type) { if (r.isActive || e.buttons) return; r.pX = e.pageX, r.pY = e.pageY, o.off(t, n).on(t, n), r.timeoutId = setTimeout(i, 200) } else { if (!r.isActive) return; o.off(t, n), r = {}, s() } }; o.on("mouseover", a).on("mouseleave", a) })) }(), { getFen: n.getFen.bind(n), setFen: n.setFen.bind(n), setOrientation: n.setOrientation.bind(n), getTurn: n.getTurn.bind(n), getState: n.getState.bind(n), getOrientation: n.bottomColor.bind(n) } } }();
